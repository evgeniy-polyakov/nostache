{"version":3,"file":"nostache.mjs","sources":["../src/index.ts"],"sourcesContent":["export type ContextFunction<TArgument, TExtensions extends Record<string, unknown> = Record<string, unknown>, TExtensionName extends keyof TExtensions = keyof TExtensions> = {\r\n    (this: ContextFunction<TArgument, TExtensions, TExtensionName>, ...args: TArgument[]): Promise<string>,\r\n    [arg: number]: TArgument,\r\n} & Iterable<TArgument> & {\r\n    escape(value: unknown): Promise<string>,\r\n    import(value: string): TemplateFunction;\r\n} & {\r\n    [name in TExtensionName]: TExtensions[TExtensionName];\r\n};\r\nexport type TemplateFunction = {\r\n    <TArgument>(...args: TArgument[]): Promise<string>;\r\n    toString(): string;\r\n};\r\nexport type TemplateOptions = {\r\n    verbose?: boolean;\r\n    async?: boolean;\r\n    cache?: boolean | \"import\" | \"function\";\r\n    import?(value: string): string | Promise<string>;\r\n    escape?(value: string): string | Promise<string>;\r\n    extensions: Record<string, unknown>;\r\n};\r\nexport type TemplateCache = {\r\n    get(key: string, options?: \"function\" | \"async\"): TemplateFunction;\r\n    get(key: string, options: \"import\"): string;\r\n    set(key: string, value: TemplateFunction, options?: \"function\" | \"async\"): void;\r\n    set(key: string, value: string): void;\r\n    delete(key: string, options?: \"import\" | \"function\" | \"async\"): void;\r\n    clear(options?: \"import\" | \"function\" | \"async\"): void;\r\n};\r\nconst ASYNC = \"async\";\r\nconst IMPORT = \"import\";\r\nconst FUNCTION = \"function\";\r\nconst isString = (s: unknown): s is string => typeof s === \"string\";\r\nconst isFunction = (f: unknown): f is { (...args: any): any } => typeof f === FUNCTION;\r\n\r\nconst parseTemplate = (template: string, options: TemplateOptions) => {\r\n\r\n    const WHITESPACE = \" \".charCodeAt(0);\r\n    const TAB = \"\\t\".charCodeAt(0);\r\n    const RETURN = \"\\r\".charCodeAt(0);\r\n    const NEWLINE = \"\\n\".charCodeAt(0);\r\n    const UNDERSCORE = \"_\".charCodeAt(0);\r\n    const LOWERCASE_A = \"a\".charCodeAt(0);\r\n    const LOWERCASE_Z = \"z\".charCodeAt(0);\r\n    const UPPERCASE_A = \"A\".charCodeAt(0);\r\n    const UPPERCASE_Z = \"Z\".charCodeAt(0);\r\n    const NUMBER_0 = \"0\".charCodeAt(0);\r\n    const NUMBER_9 = \"9\".charCodeAt(0);\r\n    const OPEN_ANGLE = \"<\".charCodeAt(0);\r\n    const CLOSE_ANGLE = \">\".charCodeAt(0);\r\n    const OPEN_BRACE = \"{\".charCodeAt(0);\r\n    const CLOSE_BRACE = \"}\".charCodeAt(0);\r\n    const OPEN_PARENTHESES = \"(\".charCodeAt(0);\r\n    const CLOSE_PARENTHESES = \")\".charCodeAt(0);\r\n    const ASSIGN = \"=\".charCodeAt(0);\r\n    const TILDE = \"~\".charCodeAt(0);\r\n    const SLASH = \"/\".charCodeAt(0);\r\n    const ASTERISK = \"*\".charCodeAt(0);\r\n    const BACKSLASH = \"\\\\\".charCodeAt(0);\r\n    const APOSTROPHE = \"'\".charCodeAt(0);\r\n    const QUOTE = \"\\\"\".charCodeAt(0);\r\n    const BACKTICK = \"`\".charCodeAt(0);\r\n    const DOLLAR = \"$\".charCodeAt(0);\r\n    const AT_SIGN = \"@\".charCodeAt(0);\r\n    const isWhitespace = (c: number) => c === WHITESPACE || c === TAB || c === RETURN || c === NEWLINE;\r\n    const isAlphabetic = (c: number) => c === UNDERSCORE || (c >= LOWERCASE_A && c <= LOWERCASE_Z) || (c >= UPPERCASE_A && c <= UPPERCASE_Z);\r\n    const isAlphanumeric = (c: number) => isAlphabetic(c) || (c >= NUMBER_0 && c <= NUMBER_9);\r\n    const asyncModifier = options.async ? \"async \" : \"\";\r\n    const charAt = (i: number) => template.charCodeAt(i);\r\n\r\n    let index = 0;\r\n    let startIndex = 0;\r\n    const length = template.length;\r\n    let funcBody = \"\";\r\n\r\n    const appendResult = (endIndex = index, extra = \"\") => {\r\n        if (endIndex > startIndex || extra) {\r\n            funcBody += `yield \\`${template.slice(startIndex, endIndex)}${extra}\\`;\\n`;\r\n        }\r\n    };\r\n\r\n    const appendOutput = (unsafe: boolean) => {\r\n        if (index > startIndex) {\r\n            funcBody += unsafe ?\r\n                `yield (${template.slice(startIndex, index)});\\n` :\r\n                `yield this.escape(${template.slice(startIndex, index)});\\n`;\r\n        }\r\n    };\r\n\r\n    const appendLogic = () => {\r\n        if (index > startIndex) {\r\n            funcBody += template.slice(startIndex, index);\r\n        }\r\n    };\r\n\r\n    const throwEndOfBlockExpected = (block: string) => {\r\n        throw new SyntaxError(`Expected end of ${block} at\\n${template}`);\r\n    };\r\n\r\n    const throwEndOfDeclarationBlockExpected = () => throwEndOfBlockExpected(\"declaration block @}\");\r\n\r\n    const parseOpenBlock = (c: number) => {\r\n        const n = charAt(index + 1);\r\n        if (c === OPEN_ANGLE && n === OPEN_BRACE) {\r\n            // Logic block <{\r\n            appendResult();\r\n            index += 2;\r\n            parseLogicBlock();\r\n            return true;\r\n        } else if (c === OPEN_BRACE && n === ASSIGN) {\r\n            // Assignment block {=\r\n            appendResult();\r\n            index += 2;\r\n            parseOutputBlock(false);\r\n            return true;\r\n        } else if (c === OPEN_BRACE && n === TILDE) {\r\n            // Unescape assignment block {~\r\n            appendResult();\r\n            index += 2;\r\n            parseOutputBlock(true);\r\n            return true;\r\n        } else if (c === OPEN_BRACE && n === AT_SIGN) {\r\n            // Declaration block {@\r\n            appendResult();\r\n            index += 2;\r\n            parseDeclaration();\r\n            return true;\r\n        } else if (c === BACKSLASH) {\r\n            // escape backslash \\\r\n            appendResult(index, \"\\\\\\\\\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        } else if (c === BACKTICK) {\r\n            // escape backtick\r\n            appendResult(index, \"\\\\`\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        } else if (c === DOLLAR) {\r\n            // escape dollar\r\n            appendResult(index, \"\\\\$\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    const parseLogicBlock = () => {\r\n        startIndex = index;\r\n        let isPotentialHtml = false;\r\n        while (index < length) {\r\n            if (parseStringOrComment()) {\r\n                continue;\r\n            }\r\n            const c = charAt(index);\r\n            if (c === OPEN_BRACE) {\r\n                index++;\r\n                const n = charAt(index);\r\n                if (n === CLOSE_ANGLE) {\r\n                    isPotentialHtml = false;\r\n                    appendLogic();\r\n                    index++;\r\n                    parseTextBlock();\r\n                } else if (n === ASSIGN || n === TILDE) {\r\n                    isPotentialHtml = false;\r\n                    appendLogic();\r\n                    index++;\r\n                    parseOutputBlock(n === TILDE);\r\n                    startIndex--;\r\n                } else if (n === AT_SIGN) {\r\n                    isPotentialHtml = false;\r\n                    index--;\r\n                    appendLogic();\r\n                    index += 2;\r\n                    parseDeclaration();\r\n                } else {\r\n                    isPotentialHtml = true;\r\n                }\r\n            } else if (isPotentialHtml && isWhitespace(c)) {\r\n                index++;\r\n            } else if (isPotentialHtml && c === OPEN_ANGLE) {\r\n                isPotentialHtml = false;\r\n                appendLogic();\r\n                parseHtmlBlock();\r\n            } else if (c === CLOSE_BRACE && charAt(index + 1) === CLOSE_ANGLE) {\r\n                appendLogic();\r\n                index += 2;\r\n                startIndex = index;\r\n                return;\r\n            } else {\r\n                index++;\r\n                isPotentialHtml = false;\r\n            }\r\n        }\r\n        throwEndOfBlockExpected(\"logic block }>\");\r\n    };\r\n\r\n    const parseHtmlBlock = () => {\r\n        startIndex = index;\r\n        let potentialEnd = -1;\r\n        while (index < length) {\r\n            const c = charAt(index);\r\n            if (c === CLOSE_ANGLE) {\r\n                index++;\r\n                potentialEnd = index;\r\n            } else if (potentialEnd >= 0 && isWhitespace(c)) {\r\n                index++;\r\n            } else if (potentialEnd >= 0 && parseStringOrComment(true)) {\r\n                // continue\r\n            } else if (potentialEnd >= 0 && c === CLOSE_BRACE) {\r\n                appendResult(potentialEnd);\r\n                startIndex = index;\r\n                return;\r\n            } else if (parseOpenBlock(c)) {\r\n                // continue\r\n            } else {\r\n                index++;\r\n                potentialEnd = -1;\r\n            }\r\n        }\r\n        throwEndOfBlockExpected(\"html block >}\");\r\n    };\r\n\r\n    const parseTextBlock = () => {\r\n        startIndex = index;\r\n        let potentialEnd = -1;\r\n        let potentialEndWhitespace = -1;\r\n        let hasMeaningfulSymbol = false;\r\n        while (index < length) {\r\n            const c = charAt(index);\r\n            if (!hasMeaningfulSymbol && isWhitespace(c)) {\r\n                startIndex++;\r\n                index++;\r\n            } else if (parseOpenBlock(c)) {\r\n                hasMeaningfulSymbol = true;\r\n                potentialEnd = -1;\r\n                potentialEndWhitespace = -1;\r\n            } else if (c === OPEN_ANGLE || isWhitespace(c)) {\r\n                if (potentialEndWhitespace < 0) potentialEndWhitespace = index;\r\n                if (c === OPEN_ANGLE) potentialEnd = index;\r\n                index++;\r\n            } else if (potentialEnd >= 0 && isWhitespace(c)) {\r\n                index++;\r\n            } else if (potentialEnd >= 0 && c === CLOSE_BRACE) {\r\n                if (hasMeaningfulSymbol) {\r\n                    appendResult(potentialEndWhitespace);\r\n                }\r\n                startIndex = index;\r\n                return;\r\n            } else {\r\n                index++;\r\n                potentialEnd = -1;\r\n                potentialEndWhitespace = -1;\r\n                hasMeaningfulSymbol = true;\r\n            }\r\n        }\r\n        throwEndOfBlockExpected(\"text block <}\");\r\n    };\r\n\r\n    const parseOutputBlock = (unsafe: boolean) => {\r\n        startIndex = index;\r\n        const closeChar = unsafe ? TILDE : ASSIGN;\r\n        let hasMeaningfulSymbol = false;\r\n        let hasOnlyComment = false;\r\n        while (index < length) {\r\n            const sc = parseStringOrComment();\r\n            if (sc === 1) {\r\n                hasMeaningfulSymbol = true;\r\n                continue;\r\n            } else if (sc === 2 && !hasMeaningfulSymbol) {\r\n                hasOnlyComment = true;\r\n                startIndex = index;\r\n            }\r\n            const c = charAt(index);\r\n            if (!hasMeaningfulSymbol && isWhitespace(c)) {\r\n                index++;\r\n            } else if (c === closeChar && charAt(index + 1) === CLOSE_BRACE) {\r\n                if (hasMeaningfulSymbol) {\r\n                    appendOutput(unsafe);\r\n                } else if (!hasOnlyComment) {\r\n                    funcBody += `yield \\`${template.slice(startIndex, index)}\\`;`;\r\n                }\r\n                index += 2;\r\n                startIndex = index;\r\n                return;\r\n            } else {\r\n                index++;\r\n                hasMeaningfulSymbol = true;\r\n            }\r\n        }\r\n        throwEndOfBlockExpected(`output block ${unsafe ? \"~}\" : \"=}\"}`);\r\n    };\r\n\r\n    const parseStringOrComment = (onlyComment = false) => {\r\n        let isInString = 0;\r\n        let isInComment = 0;\r\n        let result = 0;\r\n        while (index < length) {\r\n            const c = charAt(index);\r\n            let n = 0;\r\n            if (!onlyComment && !isInString && !isInComment && (c === APOSTROPHE || c === QUOTE || c === BACKTICK)) {\r\n                isInString = c;\r\n                index++;\r\n                result = 1;\r\n            } else if (isInString && c === BACKSLASH) {\r\n                index += 2;\r\n            } else if (isInString && c === isInString) {\r\n                index++;\r\n                return 1;\r\n            } else if (!isInString && !isInComment && c === SLASH && ((n = charAt(index + 1)) === SLASH || n === ASTERISK)) {\r\n                isInComment = n;\r\n                index += 2;\r\n                result = 2;\r\n            } else if (isInComment === SLASH && c === NEWLINE) {\r\n                index++;\r\n                return 2;\r\n            } else if (isInComment === ASTERISK && c === ASTERISK && charAt(index + 1) === SLASH) {\r\n                index += 2;\r\n                return 2;\r\n            } else if (isInComment || isInString) {\r\n                index++;\r\n            } else {\r\n                return 0;\r\n            }\r\n        }\r\n        if (result && isInString) {\r\n            throwEndOfBlockExpected(`string ${String.fromCharCode(isInString)}`);\r\n        }\r\n        if (result && isInComment === ASTERISK) {\r\n            throwEndOfBlockExpected(`comment */`);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    const parseDeclaration = () => {\r\n        startIndex = index;\r\n        let firstChar = 0;\r\n        let potentialName = false;\r\n        let name = \"\";\r\n        while (index < length) {\r\n            let c = charAt(index);\r\n            if (!firstChar) {\r\n                c = skipWhitespace();\r\n                if (parseStringOrComment(true)) {\r\n                    c = skipWhitespace();\r\n                }\r\n                startIndex = index;\r\n                firstChar = c;\r\n                if (c === OPEN_PARENTHESES) {\r\n                    index++;\r\n                    parseTemplateDeclaration();\r\n                    break;\r\n                } else if (c === APOSTROPHE || c === QUOTE || c === BACKTICK) {\r\n                    index++;\r\n                    parseImportDeclaration();\r\n                    break;\r\n                } else if (isAlphabetic(firstChar)) {\r\n                    index++;\r\n                    potentialName = true;\r\n                } else if (c === AT_SIGN && charAt(index + 1) === CLOSE_BRACE) {\r\n                    index += 2;\r\n                    startIndex = index;\r\n                    return;\r\n                } else {\r\n                    parseParametersDeclaration();\r\n                    break;\r\n                }\r\n            } else if (potentialName && isAlphanumeric(c)) {\r\n                index++;\r\n            } else if (potentialName && !isAlphanumeric(c)) {\r\n                name = template.slice(startIndex, index);\r\n                c = skipWhitespace();\r\n                if (parseStringOrComment(true)) {\r\n                    c = skipWhitespace();\r\n                }\r\n                if (c === OPEN_PARENTHESES) {\r\n                    index++;\r\n                    parseTemplateDeclaration(name);\r\n                    break;\r\n                } else if (c === APOSTROPHE || c === QUOTE || c === BACKTICK) {\r\n                    startIndex = index;\r\n                    index++;\r\n                    parseImportDeclaration(name);\r\n                    break;\r\n                } else {\r\n                    parseParametersDeclaration();\r\n                    break;\r\n                }\r\n            } else {\r\n                parseParametersDeclaration();\r\n                break;\r\n            }\r\n        }\r\n        skipWhitespace();\r\n        startIndex = index;\r\n    };\r\n\r\n    const parseParametersDeclaration = () => {\r\n        while (index < length) {\r\n            if (parseStringOrComment(true)) {\r\n                // continue\r\n            } else if (charAt(index) === AT_SIGN && charAt(index + 1) === CLOSE_BRACE && index > startIndex) {\r\n                funcBody += `let[${template.slice(startIndex, index)}]=this;\\n`;\r\n                index += 2;\r\n                return;\r\n            } else {\r\n                index++;\r\n            }\r\n        }\r\n        throwEndOfDeclarationBlockExpected();\r\n    };\r\n\r\n    const parseImportDeclaration = (name?: string) => {\r\n        while (index < length) {\r\n            if (parseStringOrComment(true)) {\r\n                // continue\r\n            } else if (charAt(index) === AT_SIGN && charAt(index + 1) === CLOSE_BRACE && index > startIndex) {\r\n                if (name) funcBody += `let ${name}=`;\r\n                funcBody += `this.import(${template.slice(startIndex, index)})\\n`;\r\n                index += 2;\r\n                return;\r\n            } else {\r\n                index++;\r\n            }\r\n        }\r\n        throwEndOfDeclarationBlockExpected();\r\n    };\r\n\r\n    const parseTemplateDeclaration = (name?: string) => {\r\n        startIndex = index;\r\n        let parameters = \"\";\r\n        let parentheses = 0;\r\n        while (index < length) {\r\n            const c = charAt(index);\r\n            if (c === OPEN_PARENTHESES) {\r\n                parentheses++;\r\n            } else if (c === CLOSE_PARENTHESES) {\r\n                if (parentheses) {\r\n                    parentheses--;\r\n                    index++;\r\n                } else {\r\n                    parameters = template.slice(startIndex, index);\r\n                    index++;\r\n                    skipWhitespace();\r\n                    startIndex = index;\r\n                    break;\r\n                }\r\n            } else {\r\n                index++;\r\n            }\r\n        }\r\n        const tempFuncBody = funcBody;\r\n        let lastWhitespace = -1;\r\n        funcBody = \"\";\r\n        while (index < length) {\r\n            const c = charAt(index);\r\n            if (isWhitespace(c)) {\r\n                lastWhitespace = index;\r\n                skipWhitespace();\r\n            } else if (c === AT_SIGN && charAt(index + 1) === CLOSE_BRACE) {\r\n                appendResult(lastWhitespace > -1 ? lastWhitespace : index);\r\n                const innerFuncBody = funcBody;\r\n                funcBody = tempFuncBody;\r\n                if (name) {\r\n                    funcBody += `let ${name}=`;\r\n                }\r\n                funcBody += `(${asyncModifier}${FUNCTION}*(${parameters}){${innerFuncBody}}.bind(this))\\n`;\r\n                index += 2;\r\n                return;\r\n            } else if (parseOpenBlock(c)) {\r\n                // continue\r\n            } else {\r\n                index++;\r\n            }\r\n        }\r\n        throwEndOfDeclarationBlockExpected();\r\n    };\r\n\r\n    const skipWhitespace = () => {\r\n        let c = charAt(index);\r\n        while (index < length && isWhitespace(c)) {\r\n            index++;\r\n            c = charAt(index);\r\n        }\r\n        return c;\r\n    };\r\n\r\n    while (index < length) {\r\n        const c = charAt(index);\r\n        if (parseOpenBlock(c)) {\r\n            // continue\r\n        } else {\r\n            index++;\r\n        }\r\n    }\r\n    appendResult();\r\n    return `return(${asyncModifier}${FUNCTION}*(){\\n${funcBody}}).call(this)`;\r\n};\r\n\r\nconst iterateRecursively = (value: any) => {\r\n    if (value && isFunction(value.next)) {\r\n        let result = \"\";\r\n        let loop = () => new Promise(r => r(value.next())).then((chunk: any): string | Promise<string> =>\r\n            chunk.done ? result : iterateRecursively(chunk.value).then(s => result = result + s).then(loop));\r\n        return loop().then(() => result);\r\n    }\r\n    return new Promise<string>(r => r(value));\r\n};\r\n\r\nconst isBrowser = Function(`try{return this===window;}catch(e){}`)();\r\n\r\nconst Nostache: {\r\n    (template: string | Promise<string>, options?: TemplateOptions): TemplateFunction;\r\n    readonly options: TemplateOptions,\r\n    readonly cache: TemplateCache,\r\n} = ((template: string | Promise<string>, options?: TemplateOptions): TemplateFunction => {\r\n    options = {\r\n        ...Nostache.options,\r\n        ...options\r\n    };\r\n    const extensions = {\r\n        ...(Nostache.options ? Nostache.options.extensions : undefined),\r\n        ...(options ? options.extensions : undefined)\r\n    };\r\n    const cache = options.cache;\r\n    const isAllCache = cache === undefined || cache === true;\r\n    const isImportCache = isAllCache || cache === IMPORT;\r\n    const isFunctionCache = isAllCache || cache === FUNCTION;\r\n    const escapeFunc = (value: unknown) => {\r\n        return iterateRecursively(value).then(\r\n            isFunction(options.escape) ? options.escape :\r\n                (s => s === undefined || s === null ? \"\" : String(s).replace(/[&<>\"']/g, c => `&#${c.charCodeAt(0)};`)));\r\n    };\r\n    const importFunc = (value: string) => (...args: unknown[]): Promise<string> => {\r\n        return Nostache(new Promise<string>((res, rej) => {\r\n            const cachedTemplate = isImportCache ? Nostache.cache.get(value, IMPORT) : undefined;\r\n            if (cachedTemplate !== undefined) {\r\n                res(cachedTemplate);\r\n            } else {\r\n                const cacheAndResolve = (template: string) => {\r\n                    if (isImportCache) {\r\n                        Nostache.cache.set(value, template);\r\n                    }\r\n                    res(template);\r\n                };\r\n                try {\r\n                    const optionsImport = options.import;\r\n                    if (isFunction(optionsImport)) {\r\n                        new Promise<string>(r => r(optionsImport(value))).then(cacheAndResolve);\r\n                    } else if (isBrowser) {\r\n                        fetch(value).then(response => response.status === 200 ? response.text().then(cacheAndResolve) : rej(new Error(`${response.status} ${response.url}`)));\r\n                    } else {\r\n                        require(\"fs\").readFile(value, \"utf8\", (error: any, data: string) => error ? rej(error) : cacheAndResolve(data));\r\n                    }\r\n                } catch (e) {\r\n                    rej(e);\r\n                }\r\n            }\r\n        }), options)(...args);\r\n    };\r\n    const returnFunc = (...args: unknown[]): Promise<string> =>\r\n        new Promise<string>(r => r(template))\r\n            .then((templateString: string) => {\r\n                const cacheOptions = options.async ? ASYNC : undefined;\r\n                let templateFunc = isFunctionCache ? Nostache.cache.get(templateString, cacheOptions) : undefined;\r\n                const templateFuncBody = templateFunc ? templateFunc.toString() : parseTemplate(templateString, options);\r\n                returnFunc.toString = () => `${FUNCTION} () {\\n${templateFuncBody}\\n}`;\r\n                try {\r\n                    if (!templateFunc) {\r\n                        templateFunc = Function(templateFuncBody) as TemplateFunction;\r\n                        templateFunc.toString = () => templateFuncBody;\r\n                        if (isFunctionCache) {\r\n                            Nostache.cache.set(templateString, templateFunc, cacheOptions);\r\n                        }\r\n                    }\r\n                    if (options.verbose) {\r\n                        console.groupCollapsed(`(${FUNCTION} () {`);\r\n                        console.log(`${templateFuncBody}})\\n(`, ...(args as any[]).reduce((a, t) => {\r\n                            if (a.length > 0) a.push(\",\");\r\n                            a.push(isString(t) ? `\"${t}\"` : t);\r\n                            return a;\r\n                        }, []), \")\")\r\n                        console.groupEnd();\r\n                    }\r\n                    const contextFunc = ((...args: unknown[]) => returnFunc(...args)) as ContextFunction<unknown>;\r\n                    contextFunc[Symbol.iterator] = function* () {\r\n                        yield* args;\r\n                    };\r\n                    for (let i = 0; i < args.length; i++) {\r\n                        contextFunc[i] = args[i];\r\n                    }\r\n                    contextFunc.import = importFunc;\r\n                    contextFunc.escape = escapeFunc;\r\n                    for (const name in extensions) {\r\n                        contextFunc[name] = extensions[name];\r\n                    }\r\n                    return iterateRecursively(templateFunc.apply(contextFunc));\r\n                } catch (error: any) {\r\n                    error.message += `\\nat ${FUNCTION} () {\\n${templateFuncBody}\\n})(${\r\n                        args.map(t => isString(t) ? `\"${t}\"` : t).join(\", \")\r\n                    })`;\r\n                    throw error;\r\n                }\r\n            });\r\n    return returnFunc;\r\n}) as typeof Nostache;\r\n\r\n(Nostache as { options: TemplateOptions }).options = {} as TemplateOptions;\r\n(Nostache as { cache: TemplateCache }).cache = (() => {\r\n    const cache = {\r\n        [IMPORT]: {} as Record<string, string>,\r\n        [ASYNC]: {} as Record<string, TemplateFunction>,\r\n        [FUNCTION]: {} as Record<string, TemplateFunction>,\r\n    };\r\n    return {\r\n        get(key: string, options?: \"import\" | \"function\" | \"async\") {\r\n            return cache[options || FUNCTION][key];\r\n        },\r\n        set(key: string, value: TemplateFunction | string, options?: \"function\" | \"async\") {\r\n            cache[isString(value) ? IMPORT : (options || FUNCTION)][key] = value;\r\n        },\r\n        delete(key: string, options?: \"import\" | \"function\" | \"async\") {\r\n            delete cache[options || FUNCTION][key];\r\n        },\r\n        clear(options?: \"import\" | \"function\" | \"async\") {\r\n            if (options) {\r\n                cache[options] = {};\r\n            } else {\r\n                cache[IMPORT] = {};\r\n                cache[ASYNC] = {};\r\n                cache[FUNCTION] = {};\r\n            }\r\n        },\r\n    } as TemplateCache;\r\n})();\r\n\r\nexport default Nostache;"],"names":[],"mappings":"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"}