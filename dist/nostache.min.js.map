{"version":3,"file":"nostache.min.js","sources":["../src/index.ts"],"sourcesContent":["const templateCache: Record<string, string> = {};\r\n\r\nfunction parseTemplate(template: string) {\r\n\r\n    function charCode(char: string) {\r\n        if (char.length > 1) {\r\n            const map: Record<number, boolean> = {};\r\n            for (let i = 0; i < char.length; i++) {\r\n                map[char.charCodeAt(i)] = true;\r\n            }\r\n            return map;\r\n        }\r\n        return char.charCodeAt(0);\r\n    }\r\n\r\n    const isWhitespace = charCode(\" \\t\\r\\n\") as Record<number, boolean>;\r\n    const OPEN_ANGLE = charCode(\"<\");\r\n    const CLOSE_ANGLE = charCode(\">\");\r\n    const OPEN_BRACE = charCode(\"{\");\r\n    const CLOSE_BRACE = charCode(\"}\");\r\n    const SEMICOLON = charCode(\";\");\r\n    const ASSIGN = charCode(\"=\");\r\n    const BACKSLASH = charCode(\"\\\\\");\r\n    const QUOTE = charCode(\"'\");\r\n    const NEWLINE = charCode(\"\\n\");\r\n    const CARRIAGE_RETURN = charCode(\"\\r\");\r\n\r\n    let index = 0;\r\n    let startIndex = 0;\r\n    const length = template.length;\r\n    let funcBody = \"\";\r\n\r\n    function appendResult(endIndex = index, extra = \"\") {\r\n        if (endIndex > startIndex || extra) {\r\n            funcBody += `yield '${template.slice(startIndex, endIndex)}${extra}';\\n`;\r\n        }\r\n    }\r\n\r\n    function appendOutput() {\r\n        if (index > startIndex) {\r\n            funcBody += `yield ${template.slice(startIndex, index)};\\n`;\r\n        }\r\n    }\r\n\r\n    function appendLogic() {\r\n        if (index > startIndex) {\r\n            funcBody += `${template.slice(startIndex, index)}`;\r\n        }\r\n    }\r\n\r\n    function parseOpenBlock(c: number) {\r\n        if (c === OPEN_ANGLE && template.charCodeAt(index + 1) === OPEN_BRACE) {\r\n            // Logic block <{\r\n            appendResult();\r\n            index += 2;\r\n            parseLogicBlock();\r\n            return true;\r\n        } else if (c === ASSIGN && template.charCodeAt(index + 1) === OPEN_BRACE) {\r\n            // Assignment block ={\r\n            appendResult();\r\n            index += 2;\r\n            parseOutputBlock();\r\n            return true;\r\n        } else if (c === OPEN_ANGLE && template.charCodeAt(index + 1) === SEMICOLON && template.charCodeAt(index + 2) === CLOSE_ANGLE) {\r\n            // End of expression block <;>\r\n            appendResult();\r\n            index++;\r\n            startIndex = index;\r\n            index++;\r\n            appendLogic();\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        } else if (c === NEWLINE) {\r\n            appendResult(index, \"\\\\n\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        } else if (c === CARRIAGE_RETURN && template.charCodeAt(index + 1) === NEWLINE) {\r\n            appendResult(index, \"\\\\n\");\r\n            index += 2;\r\n            startIndex = index;\r\n            return true;\r\n        } else if (c === BACKSLASH) {\r\n            // Escape backslash \\\r\n            appendResult(index, \"\\\\\\\\\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        } else if (c === QUOTE) {\r\n            // Escape single quote '\r\n            appendResult(index, \"\\\\'\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        } else if ((c === OPEN_ANGLE || c === ASSIGN) && template.charCodeAt(index + 1) === c && template.charCodeAt(index + 2) === OPEN_BRACE) {\r\n            // Escape open block symbols <<{ =={\r\n            index++;\r\n            appendResult();\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function parseLogicBlock() {\r\n        startIndex = index;\r\n        let isPotentialHtml = true; // We can start html block right away\r\n        for (; index < length;) {\r\n            const c = template.charCodeAt(index);\r\n            if (c === OPEN_BRACE) {\r\n                index++;\r\n                isPotentialHtml = true;\r\n            } else if (isPotentialHtml && isWhitespace[c]) {\r\n                index++;\r\n            } else if (isPotentialHtml && c === OPEN_ANGLE) {\r\n                isPotentialHtml = false;\r\n                appendLogic();\r\n                parseHtmlBlock();\r\n            } else if (c === CLOSE_BRACE && template.charCodeAt(index + 1) === CLOSE_ANGLE) {\r\n                appendLogic();\r\n                index += 2;\r\n                break;\r\n            } else {\r\n                index++;\r\n                isPotentialHtml = false;\r\n            }\r\n        }\r\n        startIndex = index;\r\n    }\r\n\r\n    function parseHtmlBlock() {\r\n        startIndex = index;\r\n        let potentialEnd = -1;\r\n        for (; index < length;) {\r\n            const c = template.charCodeAt(index);\r\n            if (c === CLOSE_ANGLE) {\r\n                index++;\r\n                potentialEnd = index;\r\n            } else if (potentialEnd >= 0 && isWhitespace[c]) {\r\n                index++;\r\n            } else if (potentialEnd >= 0 && c === CLOSE_BRACE) {\r\n                appendResult(potentialEnd);\r\n                break;\r\n            } else if (parseOpenBlock(c)) {\r\n                // continue\r\n            } else {\r\n                index++;\r\n                potentialEnd = -1;\r\n            }\r\n        }\r\n        startIndex = index;\r\n    }\r\n\r\n    function parseOutputBlock() {\r\n        startIndex = index;\r\n        let hasMeaningfulSymbol = false;\r\n        for (; index < length;) {\r\n            const c = template.charCodeAt(index);\r\n            if (c === CLOSE_BRACE && template.charCodeAt(index + 1) === CLOSE_ANGLE) {\r\n                if (hasMeaningfulSymbol) {\r\n                    appendOutput();\r\n                }\r\n                index += 2;\r\n                break;\r\n            } else if (isWhitespace[c]) {\r\n                index++;\r\n            } else {\r\n                index++;\r\n                hasMeaningfulSymbol = true;\r\n            }\r\n        }\r\n        startIndex = index;\r\n    }\r\n\r\n    for (; index < length;) {\r\n        const c = template.charCodeAt(index);\r\n        if (parseOpenBlock(c)) {\r\n            // continue\r\n        } else {\r\n            index++;\r\n        }\r\n    }\r\n    appendResult();\r\n\r\n    return `return[...(function*(){\\n${funcBody}}).call(this)].join(\"\")`;\r\n}\r\n\r\nfunction Nostache(template: string): (context?: unknown) => string & {\r\n    verbose: boolean,\r\n    contextDecomposition: boolean,\r\n} {\r\n    const funcBody = templateCache[template] ?? (templateCache[template] = parseTemplate(template));\r\n\r\n    function templateFunc(context?: unknown) {\r\n        const argNames = [];\r\n        const argValues = [];\r\n        const baseObject = {};\r\n        if (templateFunc.contextDecomposition && context && typeof context === \"object\" && !Array.isArray(context)) {\r\n            for (const p in context) {\r\n                if (!(p in baseObject) && /^[_a-z]\\w*$/i.test(p)) {\r\n                    argNames.push(p);\r\n                    argValues.push((context as any)[p]);\r\n                }\r\n            }\r\n        }\r\n        try {\r\n            if (templateFunc.verbose) {\r\n                console.log(`(function Nostache(${argNames.join(\", \")}) {\\n${funcBody}\\n})(`,\r\n                    ...argValues.reduce((a, t) => {\r\n                        if (a.length > 0) a.push(\",\");\r\n                        a.push(typeof t === \"string\" ? `\"${t}\"` : t);\r\n                        return a;\r\n                    }, []), \")\");\r\n            }\r\n            return Function(...argNames, funcBody).apply(context, argValues);\r\n        } catch (error: any) {\r\n            error.message += `\\nat (function (${argNames.join(\", \")}) {\\n${funcBody}\\n})(${\r\n                argValues.map(t => typeof t === \"string\" ? `\"${t}\"` : t).join(\", \")\r\n            })`;\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    templateFunc.verbose = Nostache.verbose;\r\n    templateFunc.contextDecomposition = Nostache.contextDecomposition;\r\n\r\n    return templateFunc;\r\n}\r\n\r\nNostache.verbose = false;\r\nNostache.contextDecomposition = true;\r\n\r\nexport default Nostache;"],"names":["templateCache","parseTemplate","template","charCode","char","length","map","i","charCodeAt","isWhitespace","OPEN_ANGLE","CLOSE_ANGLE","OPEN_BRACE","CLOSE_BRACE","SEMICOLON","ASSIGN","BACKSLASH","QUOTE","NEWLINE","CARRIAGE_RETURN","index","startIndex","funcBody","appendResult","endIndex","extra","slice","appendOutput","appendLogic","parseOpenBlock","c","isPotentialHtml","parseHtmlBlock","parseLogicBlock","hasMeaningfulSymbol","parseOutputBlock","potentialEnd","Nostache","_a","templateFunc","context","argNames","argValues","baseObject","contextDecomposition","Array","isArray","p","test","push","verbose","console","log","join","reduce","a","t","Function","apply","error","message"],"mappings":"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"}