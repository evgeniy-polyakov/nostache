{"version":3,"file":"nostache.min.js","sources":["../src/index.ts"],"sourcesContent":["const templateCache: Record<string, string> = {};\r\n\r\n// todo errors for unfinished expressions\r\n// todo extension functions\r\n// todo support of older browsers\r\n// todo expressions like <{ const f = {@ (a,b,c) <div>Inner Template {=i=}<div/> @} }> for inner templates in JS strings\r\n// todo expressions like {@ (a,b,c) @} for template arguments (no whitespace at the end)\r\n// todo expressions like <{ const f = {@ partials/partial.html @} }> for partials\r\n// todo remove explicit object decomposition - this would allow to store the compiled template function instead of a string\r\n// todo layout/block/region technics\r\n// todo table of control characters in readme.md\r\n// todo ; before yield in some cases\r\nconst parseTemplate = (template: string) => {\r\n\r\n    const charCode = (char: string) => {\r\n        if (char.length > 1) {\r\n            const map: Record<number, boolean> = {};\r\n            for (let i = 0; i < char.length; i++) {\r\n                map[char.charCodeAt(i)] = true;\r\n            }\r\n            return map;\r\n        }\r\n        return char.charCodeAt(0);\r\n    };\r\n\r\n    const isWhitespace = charCode(\" \\t\\r\\n\") as Record<number, boolean>;\r\n    const OPEN_ANGLE = charCode(\"<\");\r\n    const CLOSE_ANGLE = charCode(\">\");\r\n    const OPEN_BRACE = charCode(\"{\");\r\n    const CLOSE_BRACE = charCode(\"}\");\r\n    const ASSIGN = charCode(\"=\");\r\n    const TILDE = charCode(\"~\");\r\n    const SLASH = charCode(\"/\");\r\n    const ASTERISK = charCode(\"*\");\r\n    const NEWLINE = charCode(\"\\n\");\r\n    const BACKSLASH = charCode(\"\\\\\");\r\n    const APOSTROPHE = charCode(\"'\");\r\n    const QUOTE = charCode(\"\\\"\");\r\n    const BACKTICK = charCode(\"`\");\r\n    const DOLLAR = charCode(\"$\");\r\n\r\n    let index = 0;\r\n    let startIndex = 0;\r\n    const length = template.length;\r\n    let funcBody = \"\";\r\n\r\n    const appendResult = (endIndex = index, extra = \"\") => {\r\n        if (endIndex > startIndex || extra) {\r\n            funcBody += `yield \\`${template.slice(startIndex, endIndex)}${extra}\\`;\\n`;\r\n        }\r\n    };\r\n\r\n    const appendOutput = (unsafe: boolean) => {\r\n        if (index > startIndex) {\r\n            funcBody += unsafe ?\r\n                `yield (${template.slice(startIndex, index)});\\n` :\r\n                `yield this.escape(${template.slice(startIndex, index)});\\n`;\r\n        }\r\n    };\r\n\r\n    const appendLogic = () => {\r\n        if (index > startIndex) {\r\n            funcBody += `${template.slice(startIndex, index)}`;\r\n        }\r\n    };\r\n\r\n    const parseOpenBlock = (c: number) => {\r\n        if (c === OPEN_ANGLE && template.charCodeAt(index + 1) === OPEN_BRACE) {\r\n            // Logic block <{\r\n            appendResult();\r\n            index += 2;\r\n            parseLogicBlock();\r\n            return true;\r\n        } else if (c === OPEN_BRACE && template.charCodeAt(index + 1) === ASSIGN) {\r\n            // Assignment block ={\r\n            appendResult();\r\n            index += 2;\r\n            parseOutputBlock(false);\r\n            return true;\r\n        } else if (c === OPEN_BRACE && template.charCodeAt(index + 1) === TILDE) {\r\n            // Unsafe assignment block ~{\r\n            appendResult();\r\n            index += 2;\r\n            parseOutputBlock(true);\r\n            return true;\r\n        } else if (c === BACKSLASH) {\r\n            // Escape backslash \\\r\n            appendResult(index, \"\\\\\\\\\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        } else if (c === BACKTICK) {\r\n            // Escape backtick\r\n            appendResult(index, \"\\\\`\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        } else if (c === DOLLAR) {\r\n            // Escape dollar\r\n            appendResult(index, \"\\\\$\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    const parseLogicBlock = () => {\r\n        startIndex = index;\r\n        let isPotentialHtml = true; // We can start html block right away\r\n        for (; index < length;) {\r\n            if (parseStringOrComment()) {\r\n                isPotentialHtml = false;\r\n                continue;\r\n            }\r\n            const c = template.charCodeAt(index);\r\n            if (c === OPEN_BRACE) {\r\n                index++;\r\n                const n = template.charCodeAt(index);\r\n                if (n === CLOSE_ANGLE) {\r\n                    isPotentialHtml = false;\r\n                    appendLogic();\r\n                    index++;\r\n                    parseTextBlock();\r\n                } else if (n === ASSIGN || n === TILDE) {\r\n                    isPotentialHtml = false;\r\n                    appendLogic();\r\n                    index++;\r\n                    parseOutputBlock(n === TILDE);\r\n                    startIndex--;\r\n                } else {\r\n                    isPotentialHtml = true;\r\n                }\r\n            } else if (isPotentialHtml && isWhitespace[c]) {\r\n                index++;\r\n            } else if (isPotentialHtml && c === OPEN_ANGLE) {\r\n                isPotentialHtml = false;\r\n                appendLogic();\r\n                parseHtmlBlock();\r\n            } else if (c === CLOSE_BRACE && template.charCodeAt(index + 1) === CLOSE_ANGLE) {\r\n                appendLogic();\r\n                index += 2;\r\n                break;\r\n            } else {\r\n                index++;\r\n                isPotentialHtml = false;\r\n            }\r\n        }\r\n        startIndex = index;\r\n    };\r\n\r\n    const parseHtmlBlock = () => {\r\n        startIndex = index;\r\n        let potentialEnd = -1;\r\n        for (; index < length;) {\r\n            const c = template.charCodeAt(index);\r\n            if (c === CLOSE_ANGLE) {\r\n                index++;\r\n                potentialEnd = index;\r\n            } else if (potentialEnd >= 0 && isWhitespace[c]) {\r\n                index++;\r\n            } else if (potentialEnd >= 0 && c === CLOSE_BRACE) {\r\n                appendResult(potentialEnd);\r\n                break;\r\n            } else if (parseOpenBlock(c)) {\r\n                // continue\r\n            } else {\r\n                index++;\r\n                potentialEnd = -1;\r\n            }\r\n        }\r\n        startIndex = index;\r\n    };\r\n\r\n    const parseTextBlock = () => {\r\n        startIndex = index;\r\n        let potentialEnd = -1;\r\n        let potentialEndWhitespace = -1;\r\n        let hasMeaningfulSymbol = false;\r\n        for (; index < length;) {\r\n            const c = template.charCodeAt(index);\r\n            if (!hasMeaningfulSymbol && isWhitespace[c]) {\r\n                startIndex++;\r\n                index++;\r\n            } else if (hasMeaningfulSymbol && (c === OPEN_ANGLE || isWhitespace[c])) {\r\n                if (potentialEndWhitespace < 0) potentialEndWhitespace = index;\r\n                if (c === OPEN_ANGLE) potentialEnd = index;\r\n                index++;\r\n            } else if (potentialEnd >= 0 && isWhitespace[c]) {\r\n                index++;\r\n            } else if (potentialEnd >= 0 && c === CLOSE_BRACE) {\r\n                appendResult(potentialEndWhitespace);\r\n                break;\r\n            } else if (parseOpenBlock(c)) {\r\n                hasMeaningfulSymbol = true;\r\n            } else {\r\n                index++;\r\n                potentialEnd = -1;\r\n                potentialEndWhitespace = -1;\r\n                hasMeaningfulSymbol = true;\r\n            }\r\n        }\r\n        startIndex = index;\r\n    };\r\n\r\n    const parseOutputBlock = (unsafe: boolean) => {\r\n        startIndex = index;\r\n        const closeChar = unsafe ? TILDE : ASSIGN;\r\n        let hasMeaningfulSymbol = false;\r\n        for (; index < length;) {\r\n            if (parseStringOrComment()) {\r\n                hasMeaningfulSymbol = true;\r\n                continue;\r\n            }\r\n            const c = template.charCodeAt(index);\r\n            if (!hasMeaningfulSymbol && isWhitespace[c]) {\r\n                index++;\r\n            } else if (c === closeChar && template.charCodeAt(index + 1) === CLOSE_BRACE) {\r\n                if (hasMeaningfulSymbol) {\r\n                    appendOutput(unsafe);\r\n                }\r\n                index += 2;\r\n                break;\r\n            } else {\r\n                index++;\r\n                hasMeaningfulSymbol = true;\r\n            }\r\n        }\r\n        startIndex = index;\r\n    };\r\n\r\n    const parseStringOrComment = () => {\r\n        let isInString = 0;\r\n        let isInComment = 0;\r\n        let result = false;\r\n        for (; index < length;) {\r\n            const c = template.charCodeAt(index);\r\n            let n = 0;\r\n            if (!isInString && !isInComment && (c === APOSTROPHE || c === QUOTE || c === BACKTICK)) {\r\n                isInString = c;\r\n                index++;\r\n                result = true;\r\n            } else if (isInString && c === BACKSLASH) {\r\n                index += 2;\r\n            } else if (isInString && c === isInString) {\r\n                isInString = 0;\r\n                index++;\r\n                return true;\r\n            } else if (!isInString && !isInComment && c === SLASH && ((n = template.charCodeAt(index + 1)) === SLASH || n === ASTERISK)) {\r\n                isInComment = n;\r\n                index += 2;\r\n                result = true;\r\n            } else if (isInComment === SLASH && c === NEWLINE) {\r\n                isInComment = 0;\r\n                index++;\r\n            } else if (isInComment === ASTERISK && c === ASTERISK && template.charCodeAt(index + 1) === SLASH) {\r\n                isInComment = 0;\r\n                index += 2;\r\n                return true;\r\n            } else if (isInComment || isInString) {\r\n                index++;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    for (; index < length;) {\r\n        const c = template.charCodeAt(index);\r\n        if (parseOpenBlock(c)) {\r\n            // continue\r\n        } else {\r\n            index++;\r\n        }\r\n    }\r\n    appendResult();\r\n    return `return(async function*(){\\n${funcBody}}).call(this)`;\r\n}\r\n\r\nconst escape = async (value: unknown) => {\r\n    return String(await value).replace(/[&<>\"']/g, c => `&#${c.charCodeAt(0)};`);\r\n};\r\n\r\nconst iterateGenerator = async (generator: AsyncGenerator<any>) => {\r\n    let result = '';\r\n    while (true) {\r\n        const chunk = await generator.next();\r\n        if (chunk.done) {\r\n            break;\r\n        } else {\r\n            if (typeof chunk.value?.next === \"function\") {\r\n                result += await iterateGenerator(chunk.value);\r\n            } else {\r\n                result += await chunk.value;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nconst Nostache = (template: string): ((...context: unknown[]) => Promise<string>) & {\r\n    verbose: boolean,\r\n    toString(): string,\r\n    escape(value: unknown): Promise<string>,\r\n} => {\r\n    const funcBody = templateCache[template] ?? (templateCache[template] = parseTemplate(template));\r\n    const templateFunc = async (...context: unknown[]) => {\r\n        const argNames = [];\r\n        const argValues = [];\r\n        for (const c of context) {\r\n            if (c && typeof c === \"object\" && !Array.isArray(c)) {\r\n                for (const p in c) {\r\n                    if (/^[_a-z]\\w*$/i.test(p)) {\r\n                        argNames.push(p);\r\n                        argValues.push((c as any)[p]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        try {\r\n            if (templateFunc.verbose) {\r\n                console.groupCollapsed(`(function Nostache(${argNames.join(\", \")}) {`);\r\n                console.log(`${funcBody}})\\n(`, ...argValues.reduce((a, t) => {\r\n                    if (a.length > 0) a.push(\",\");\r\n                    a.push(typeof t === \"string\" ? `\"${t}\"` : t);\r\n                    return a;\r\n                }, []), \")\")\r\n                console.groupEnd();\r\n            }\r\n            const contextFunc = (...context: unknown[]) => {\r\n                return templateFunc(...context);\r\n            };\r\n            (contextFunc as any)[Symbol.iterator] = function* () {\r\n                yield* context;\r\n            };\r\n            for (let i = 0; i < context.length; i++) {\r\n                (contextFunc as any)[i] = context[i];\r\n            }\r\n            contextFunc.escape = templateFunc.escape;\r\n            const generator = Function(...argNames, funcBody).apply(contextFunc, argValues);\r\n            return iterateGenerator(generator);\r\n        } catch (error: any) {\r\n            error.message += `\\nat function (${argNames.join(\", \")}) {\\n${funcBody}\\n})(${\r\n                argValues.map(t => typeof t === \"string\" ? `\"${t}\"` : t).join(\", \")\r\n            })`;\r\n            throw error;\r\n        }\r\n    };\r\n    templateFunc.verbose = Nostache.verbose;\r\n    templateFunc.escape = escape;\r\n    templateFunc.toString = () => funcBody;\r\n    return templateFunc;\r\n};\r\n\r\nNostache.verbose = false;\r\nNostache.escape = escape;\r\n\r\nexport default Nostache;"],"names":["templateCache","escape","async","value","String","replace","c","charCodeAt","iterateGenerator","generator","result","chunk","next","done","Nostache","template","funcBody","charCode","char","length","map","i","isWhitespace","OPEN_ANGLE","CLOSE_ANGLE","OPEN_BRACE","CLOSE_BRACE","ASSIGN","TILDE","SLASH","ASTERISK","NEWLINE","BACKSLASH","APOSTROPHE","QUOTE","BACKTICK","DOLLAR","index","startIndex","appendResult","endIndex","extra","slice","appendOutput","unsafe","appendLogic","parseOpenBlock","parseLogicBlock","parseOutputBlock","isPotentialHtml","parseStringOrComment","n","parseTextBlock","parseHtmlBlock","potentialEnd","potentialEndWhitespace","hasMeaningfulSymbol","closeChar","isInString","isInComment","parseTemplate","templateFunc","context","argNames","argValues","Array","isArray","p","test","push","verbose","console","groupCollapsed","join","log","reduce","a","t","groupEnd","contextFunc","Symbol","iterator","Function","apply","error","message","toString"],"mappings":"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"}