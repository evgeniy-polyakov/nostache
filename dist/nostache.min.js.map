{"version":3,"file":"nostache.min.js","sources":["../src/index.ts"],"sourcesContent":["type ContextFunction<TArg> = Iterable<TArg> & {\r\n    (...args: TArg[]): Promise<string>,\r\n    [arg: number]: TArg,\r\n    escape(value: unknown): Promise<string>,\r\n    load(input: string | URL | Request, init?: RequestInit): TemplateFunction;\r\n};\r\ntype TemplateFunction = {\r\n    <TArg>(this: ContextFunction<TArg>, ...context: TArg[]): Promise<string>;\r\n    toString(): string;\r\n};\r\ntype TemplateOptions = {\r\n    verbose?: boolean;\r\n    async?: boolean;\r\n    cache?: boolean;\r\n    load?(input: string | URL | Request, init?: RequestInit): string | Promise<string>;\r\n    escape?(value: string): string | Promise<string>;\r\n};\r\ntype TemplateCache = Map<string, TemplateFunction>;\r\nconst templateCache: TemplateCache = new Map<string, TemplateFunction>();\r\n\r\n// todo errors for unfinished expressions\r\n// todo extension functions\r\n// todo output {=  =} or {~  ~} as whitespace `  `\r\n// todo layout/block/region technics\r\n// todo table of control characters in readme.md\r\n// todo ; before yield in some cases\r\nconst parseTemplate = (template: string, options: TemplateOptions) => {\r\n\r\n    const WHITESPACE = \" \".charCodeAt(0);\r\n    const TAB = \"\\t\".charCodeAt(0);\r\n    const RETURN = \"\\r\".charCodeAt(0);\r\n    const NEWLINE = \"\\n\".charCodeAt(0);\r\n    const UNDERSCORE = \"_\".charCodeAt(0);\r\n    const LOWERCASE_A = \"a\".charCodeAt(0);\r\n    const LOWERCASE_Z = \"z\".charCodeAt(0);\r\n    const UPPERCASE_A = \"A\".charCodeAt(0);\r\n    const UPPERCASE_Z = \"Z\".charCodeAt(0);\r\n    const NUMBER_0 = \"0\".charCodeAt(0);\r\n    const NUMBER_9 = \"9\".charCodeAt(0);\r\n    const OPEN_ANGLE = \"<\".charCodeAt(0);\r\n    const CLOSE_ANGLE = \">\".charCodeAt(0);\r\n    const OPEN_BRACE = \"{\".charCodeAt(0);\r\n    const CLOSE_BRACE = \"}\".charCodeAt(0);\r\n    const OPEN_PARENTHESES = \"(\".charCodeAt(0);\r\n    const CLOSE_PARENTHESES = \")\".charCodeAt(0);\r\n    const ASSIGN = \"=\".charCodeAt(0);\r\n    const TILDE = \"~\".charCodeAt(0);\r\n    const SLASH = \"/\".charCodeAt(0);\r\n    const ASTERISK = \"*\".charCodeAt(0);\r\n    const BACKSLASH = \"\\\\\".charCodeAt(0);\r\n    const APOSTROPHE = \"'\".charCodeAt(0);\r\n    const QUOTE = \"\\\"\".charCodeAt(0);\r\n    const BACKTICK = \"`\".charCodeAt(0);\r\n    const DOLLAR = \"$\".charCodeAt(0);\r\n    const AT_SIGN = \"@\".charCodeAt(0);\r\n    const isWhitespace = (c: number) => c === WHITESPACE || c === TAB || c === RETURN || c === NEWLINE;\r\n    const isAlphabetic = (c: number) => c === UNDERSCORE || (c >= LOWERCASE_A && c <= LOWERCASE_Z) || (c >= UPPERCASE_A && c <= UPPERCASE_Z);\r\n    const isAlphanumeric = (c: number) => isAlphabetic(c) || (c >= NUMBER_0 && c <= NUMBER_9);\r\n\r\n    let index = 0;\r\n    let startIndex = 0;\r\n    const length = template.length;\r\n    let funcBody = \"\";\r\n\r\n    const appendResult = (endIndex = index, extra = \"\") => {\r\n        if (endIndex > startIndex || extra) {\r\n            funcBody += `yield \\`${template.slice(startIndex, endIndex)}${extra}\\`;\\n`;\r\n        }\r\n    };\r\n\r\n    const appendOutput = (unescape: boolean) => {\r\n        if (index > startIndex) {\r\n            funcBody += unescape ?\r\n                `yield (${template.slice(startIndex, index)});\\n` :\r\n                `yield this.escape(${template.slice(startIndex, index)});\\n`;\r\n        }\r\n    };\r\n\r\n    const appendLogic = () => {\r\n        if (index > startIndex) {\r\n            funcBody += template.slice(startIndex, index);\r\n        }\r\n    };\r\n\r\n    const parseOpenBlock = (c: number) => {\r\n        const n = template.charCodeAt(index + 1);\r\n        if (c === OPEN_ANGLE && n === OPEN_BRACE) {\r\n            // Logic block <{\r\n            appendResult();\r\n            index += 2;\r\n            parseLogicBlock();\r\n            return true;\r\n        } else if (c === OPEN_BRACE && n === ASSIGN) {\r\n            // Assignment block {=\r\n            appendResult();\r\n            index += 2;\r\n            parseOutputBlock(false);\r\n            return true;\r\n        } else if (c === OPEN_BRACE && n === TILDE) {\r\n            // Unescape assignment block {~\r\n            appendResult();\r\n            index += 2;\r\n            parseOutputBlock(true);\r\n            return true;\r\n        } else if (c === OPEN_BRACE && n === AT_SIGN) {\r\n            // Declaration block {@\r\n            appendResult();\r\n            index += 2;\r\n            parseDeclaration();\r\n            return true;\r\n        } else if (c === BACKSLASH) {\r\n            // escape backslash \\\r\n            appendResult(index, \"\\\\\\\\\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        } else if (c === BACKTICK) {\r\n            // escape backtick\r\n            appendResult(index, \"\\\\`\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        } else if (c === DOLLAR) {\r\n            // escape dollar\r\n            appendResult(index, \"\\\\$\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    const parseLogicBlock = () => {\r\n        startIndex = index;\r\n        let isPotentialHtml = true; // We can start html block right away\r\n        while (index < length) {\r\n            if (parseStringOrComment()) {\r\n                isPotentialHtml = false;\r\n                continue;\r\n            }\r\n            const c = template.charCodeAt(index);\r\n            if (c === OPEN_BRACE) {\r\n                index++;\r\n                const n = template.charCodeAt(index);\r\n                if (n === CLOSE_ANGLE) {\r\n                    isPotentialHtml = false;\r\n                    appendLogic();\r\n                    index++;\r\n                    parseTextBlock();\r\n                } else if (n === ASSIGN || n === TILDE) {\r\n                    isPotentialHtml = false;\r\n                    appendLogic();\r\n                    index++;\r\n                    parseOutputBlock(n === TILDE);\r\n                    startIndex--;\r\n                } else if (n === AT_SIGN) {\r\n                    isPotentialHtml = false;\r\n                    index--;\r\n                    appendLogic();\r\n                    index += 2;\r\n                    parseDeclaration();\r\n                } else {\r\n                    isPotentialHtml = true;\r\n                }\r\n            } else if (isPotentialHtml && isWhitespace(c)) {\r\n                index++;\r\n            } else if (isPotentialHtml && c === OPEN_ANGLE) {\r\n                isPotentialHtml = false;\r\n                appendLogic();\r\n                parseHtmlBlock();\r\n            } else if (c === CLOSE_BRACE && template.charCodeAt(index + 1) === CLOSE_ANGLE) {\r\n                appendLogic();\r\n                index += 2;\r\n                break;\r\n            } else {\r\n                index++;\r\n                isPotentialHtml = false;\r\n            }\r\n        }\r\n        startIndex = index;\r\n    };\r\n\r\n    const parseHtmlBlock = () => {\r\n        startIndex = index;\r\n        let potentialEnd = -1;\r\n        while (index < length) {\r\n            const c = template.charCodeAt(index);\r\n            if (c === CLOSE_ANGLE) {\r\n                index++;\r\n                potentialEnd = index;\r\n            } else if (potentialEnd >= 0 && isWhitespace(c)) {\r\n                index++;\r\n            } else if (potentialEnd >= 0 && c === CLOSE_BRACE) {\r\n                appendResult(potentialEnd);\r\n                break;\r\n            } else if (parseOpenBlock(c)) {\r\n                // continue\r\n            } else {\r\n                index++;\r\n                potentialEnd = -1;\r\n            }\r\n        }\r\n        startIndex = index;\r\n    };\r\n\r\n    const parseTextBlock = () => {\r\n        startIndex = index;\r\n        let potentialEnd = -1;\r\n        let potentialEndWhitespace = -1;\r\n        let hasMeaningfulSymbol = false;\r\n        while (index < length) {\r\n            const c = template.charCodeAt(index);\r\n            if (!hasMeaningfulSymbol && isWhitespace(c)) {\r\n                startIndex++;\r\n                index++;\r\n            } else if (hasMeaningfulSymbol && (c === OPEN_ANGLE || isWhitespace(c))) {\r\n                if (potentialEndWhitespace < 0) potentialEndWhitespace = index;\r\n                if (c === OPEN_ANGLE) potentialEnd = index;\r\n                index++;\r\n            } else if (potentialEnd >= 0 && isWhitespace(c)) {\r\n                index++;\r\n            } else if (potentialEnd >= 0 && c === CLOSE_BRACE) {\r\n                appendResult(potentialEndWhitespace);\r\n                break;\r\n            } else if (parseOpenBlock(c)) {\r\n                hasMeaningfulSymbol = true;\r\n            } else {\r\n                index++;\r\n                potentialEnd = -1;\r\n                potentialEndWhitespace = -1;\r\n                hasMeaningfulSymbol = true;\r\n            }\r\n        }\r\n        startIndex = index;\r\n    };\r\n\r\n    const parseOutputBlock = (unescape: boolean) => {\r\n        startIndex = index;\r\n        const closeChar = unescape ? TILDE : ASSIGN;\r\n        let hasMeaningfulSymbol = false;\r\n        while (index < length) {\r\n            if (parseStringOrComment()) {\r\n                hasMeaningfulSymbol = true;\r\n                continue;\r\n            }\r\n            const c = template.charCodeAt(index);\r\n            if (!hasMeaningfulSymbol && isWhitespace(c)) {\r\n                index++;\r\n            } else if (c === closeChar && template.charCodeAt(index + 1) === CLOSE_BRACE) {\r\n                if (hasMeaningfulSymbol) {\r\n                    appendOutput(unescape);\r\n                }\r\n                index += 2;\r\n                break;\r\n            } else {\r\n                index++;\r\n                hasMeaningfulSymbol = true;\r\n            }\r\n        }\r\n        startIndex = index;\r\n    };\r\n\r\n    const parseStringOrComment = () => {\r\n        let isInString = 0;\r\n        let isInComment = 0;\r\n        let result = false;\r\n        while (index < length) {\r\n            const c = template.charCodeAt(index);\r\n            let n = 0;\r\n            if (!isInString && !isInComment && (c === APOSTROPHE || c === QUOTE || c === BACKTICK)) {\r\n                isInString = c;\r\n                index++;\r\n                result = true;\r\n            } else if (isInString && c === BACKSLASH) {\r\n                index += 2;\r\n            } else if (isInString && c === isInString) {\r\n                isInString = 0;\r\n                index++;\r\n                return true;\r\n            } else if (!isInString && !isInComment && c === SLASH && ((n = template.charCodeAt(index + 1)) === SLASH || n === ASTERISK)) {\r\n                isInComment = n;\r\n                index += 2;\r\n                result = true;\r\n            } else if (isInComment === SLASH && c === NEWLINE) {\r\n                isInComment = 0;\r\n                index++;\r\n            } else if (isInComment === ASTERISK && c === ASTERISK && template.charCodeAt(index + 1) === SLASH) {\r\n                isInComment = 0;\r\n                index += 2;\r\n                return true;\r\n            } else if (isInComment || isInString) {\r\n                index++;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    const parseDeclaration = () => {\r\n        startIndex = index;\r\n        let firstChar = 0;\r\n        let potentialName = false;\r\n        let name = \"\";\r\n        while (index < length) {\r\n            let c = template.charCodeAt(index);\r\n            if (!firstChar) {\r\n                c = skipWhitespace(c);\r\n                startIndex = index;\r\n                firstChar = c;\r\n                if (c === OPEN_PARENTHESES) {\r\n                    index++;\r\n                    parseTemplateDeclaration();\r\n                    break;\r\n                } else if (c === APOSTROPHE || c === QUOTE || c === BACKTICK) {\r\n                    index++;\r\n                    parseloadDeclaration();\r\n                    break;\r\n                } else if (isAlphabetic(firstChar)) {\r\n                    index++;\r\n                    potentialName = true;\r\n                } else {\r\n                    parseParametersDeclaration();\r\n                    break;\r\n                }\r\n            } else if (potentialName && isAlphanumeric(c)) {\r\n                index++;\r\n            } else if (potentialName && !isAlphanumeric(c)) {\r\n                name = template.slice(startIndex, index);\r\n                c = skipWhitespace(c);\r\n                if (c === OPEN_PARENTHESES) {\r\n                    index++;\r\n                    parseTemplateDeclaration(name);\r\n                    break;\r\n                } else if (c === APOSTROPHE || c === QUOTE || c === BACKTICK) {\r\n                    startIndex = index;\r\n                    index++;\r\n                    parseloadDeclaration(name);\r\n                    break;\r\n                } else {\r\n                    parseParametersDeclaration();\r\n                    break;\r\n                }\r\n            } else {\r\n                parseParametersDeclaration();\r\n                break;\r\n            }\r\n        }\r\n        skipWhitespace(template.charCodeAt(index));\r\n        startIndex = index;\r\n    };\r\n\r\n    const parseParametersDeclaration = () => {\r\n        while (index < length) {\r\n            if (template.charCodeAt(index) === AT_SIGN && template.charCodeAt(index + 1) === CLOSE_BRACE && index > startIndex) {\r\n                funcBody += `let[${template.slice(startIndex, index)}]=this;\\n`;\r\n                index += 2;\r\n                break;\r\n            } else {\r\n                index++;\r\n            }\r\n        }\r\n    };\r\n\r\n    const parseloadDeclaration = (name?: string) => {\r\n        while (index < length) {\r\n            if (template.charCodeAt(index) === AT_SIGN && template.charCodeAt(index + 1) === CLOSE_BRACE && index > startIndex) {\r\n                if (name) funcBody += `let ${name}=`;\r\n                funcBody += `this.load(${template.slice(startIndex, index)})\\n`;\r\n                index += 2;\r\n                break;\r\n            } else {\r\n                index++;\r\n            }\r\n        }\r\n    };\r\n\r\n    const parseTemplateDeclaration = (name?: string) => {\r\n        startIndex = index;\r\n        let parameters = \"\";\r\n        let parentheses = 0;\r\n        while (index < length) {\r\n            const c = template.charCodeAt(index);\r\n            if (c === OPEN_PARENTHESES) {\r\n                parentheses++;\r\n            } else if (c === CLOSE_PARENTHESES) {\r\n                if (parentheses) {\r\n                    parentheses--;\r\n                    index++;\r\n                } else {\r\n                    parameters = template.slice(startIndex, index);\r\n                    index++;\r\n                    skipWhitespace(template.charCodeAt(index));\r\n                    startIndex = index;\r\n                    break;\r\n                }\r\n            } else {\r\n                index++;\r\n            }\r\n        }\r\n        const tempFuncBody = funcBody;\r\n        let lastWhitespace = -1;\r\n        funcBody = \"\";\r\n        while (index < length) {\r\n            const c = template.charCodeAt(index);\r\n            if (isWhitespace(c)) {\r\n                lastWhitespace = index;\r\n                index++;\r\n            } else if (c === AT_SIGN && template.charCodeAt(index + 1) === CLOSE_BRACE) {\r\n                appendResult(lastWhitespace > -1 ? lastWhitespace : index);\r\n                const innerFuncBody = funcBody;\r\n                funcBody = tempFuncBody;\r\n                if (name) {\r\n                    funcBody += `let ${name}=`;\r\n                }\r\n                funcBody += `(${options.async ? \"async \" : \"\"}function*(${parameters}){${innerFuncBody}}.bind(this))\\n`;\r\n                index += 2;\r\n                break;\r\n            } else if (parseOpenBlock(c)) {\r\n                // continue\r\n            } else {\r\n                index++;\r\n            }\r\n        }\r\n    };\r\n\r\n    const skipWhitespace = (c: number) => {\r\n        while (index < length && isWhitespace(c)) {\r\n            index++;\r\n            c = template.charCodeAt(index);\r\n        }\r\n        return c;\r\n    };\r\n\r\n    while (index < length) {\r\n        const c = template.charCodeAt(index);\r\n        if (parseOpenBlock(c)) {\r\n            // continue\r\n        } else {\r\n            index++;\r\n        }\r\n    }\r\n    appendResult();\r\n    return `return(${options.async ? \"async \" : \"\"}function*(){\\n${funcBody}}).call(this)`;\r\n};\r\n\r\nconst iterateRecursively = (value: any) => {\r\n    if (typeof value.next === \"function\") {\r\n        let result = \"\";\r\n        let loop = () => new Promise(r => r(value.next())).then((chunk: any): string | Promise<string> =>\r\n            chunk.done ? result : iterateRecursively(chunk.value).then(s => result = result + s).then(loop));\r\n        return loop().then(() => result);\r\n    }\r\n    return new Promise<string>(r => r(value));\r\n};\r\n\r\nconst Nostache: {\r\n    (template: string | Promise<string>, options?: TemplateOptions): TemplateFunction;\r\n    readonly options: TemplateOptions,\r\n    readonly cache: TemplateCache,\r\n} = ((template: string | Promise<string>, options?: TemplateOptions): TemplateFunction => {\r\n    options = {\r\n        ...Nostache.options,\r\n        ...options,\r\n    };\r\n    const escape = (value: unknown) => {\r\n        return iterateRecursively(value).then(\r\n            typeof options.escape === \"function\" ? options.escape :\r\n                (s => String(s).replace(/[&<>\"']/g, c => `&#${c.charCodeAt(0)};`)));\r\n    };\r\n    const load = (input: string | URL | Request, init?: RequestInit) => {\r\n        return Nostache(typeof options.load === \"function\" ? options.load(input, init) : fetch(input, init).then(r => r.text()));\r\n    };\r\n    const templateFunc = (...args: unknown[]) =>\r\n        new Promise<string>(r => r(template))\r\n            .then((templateString: string) => {\r\n                const key = options.async ? `async ${templateString}` : templateString;\r\n                let func = templateCache.get(key);\r\n                const funcBody = func ? func.toString() : parseTemplate(templateString, options);\r\n                templateFunc.toString = () => `function () {\\n${funcBody}\\n}`;\r\n                try {\r\n                    if (!func) {\r\n                        func = Function(funcBody) as TemplateFunction;\r\n                        func.toString = () => funcBody;\r\n                        if (options.cache !== false) {\r\n                            templateCache.set(key, func);\r\n                        }\r\n                    }\r\n                    if (options.verbose) {\r\n                        console.groupCollapsed(`(function () {`);\r\n                        console.log(`${funcBody}})\\n(`, ...(args as any[]).reduce((a, t) => {\r\n                            if (a.length > 0) a.push(\",\");\r\n                            a.push(typeof t === \"string\" ? `\"${t}\"` : t);\r\n                            return a;\r\n                        }, []), \")\")\r\n                        console.groupEnd();\r\n                    }\r\n                    const contextFunc = ((...args: unknown[]) => templateFunc(...args)) as ContextFunction<unknown>;\r\n                    contextFunc[Symbol.iterator] = function* () {\r\n                        yield* args;\r\n                    };\r\n                    for (let i = 0; i < args.length; i++) {\r\n                        contextFunc[i] = args[i];\r\n                    }\r\n                    contextFunc.load = load;\r\n                    contextFunc.escape = escape;\r\n                    return iterateRecursively(func.apply(contextFunc));\r\n                } catch (error: any) {\r\n                    error.message += `\\nat function () {\\n${funcBody}\\n})(${\r\n                        args.map(t => typeof t === \"string\" ? `\"${t}\"` : t).join(\", \")\r\n                    })`;\r\n                    throw error;\r\n                }\r\n            });\r\n    return templateFunc;\r\n}) as typeof Nostache;\r\n\r\n(Nostache as { options: TemplateOptions }).options = {} as TemplateOptions;\r\n(Nostache as { cache: TemplateCache }).cache = templateCache;\r\n\r\nexport default Nostache;"],"names":["g","f","exports","module","define","amd","globalThis","self","Nostache","this","templateCache","Map","iterateRecursively","value","next","result","loop","Promise","r","then","chunk","done","s","template","options","escape","String","replace","c","charCodeAt","load","input","init","fetch","text","templateFunc","args","templateString","key","async","func","get","funcBody","toString","isWhitespace","isAlphabetic","isAlphanumeric","index","startIndex","length","appendResult","endIndex","extra","slice","appendOutput","unescape","appendLogic","parseOpenBlock","n","parseLogicBlock","parseOutputBlock","parseDeclaration","isPotentialHtml","parseStringOrComment","parseTextBlock","parseHtmlBlock","potentialEnd","potentialEndWhitespace","hasMeaningfulSymbol","closeChar","isInString","isInComment","firstChar","potentialName","name","skipWhitespace","parseTemplateDeclaration","parseloadDeclaration","parseParametersDeclaration","parameters","parentheses","tempFuncBody","lastWhitespace","innerFuncBody","parseTemplate","Function","cache","set","verbose","console","groupCollapsed","log","reduce","a","t","push","groupEnd","contextFunc","Symbol","iterator","i","apply","error","message","map","join"],"mappings":"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"}