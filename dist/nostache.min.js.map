{"version":3,"file":"nostache.min.js","sources":["../src/index.ts"],"sourcesContent":["export type ContextFunction<TArgument, TExtensions extends Record<string, unknown> = Record<string, unknown>, TExtensionName extends keyof TExtensions = keyof TExtensions> = {\r\n    (this: ContextFunction<TArgument, TExtensions, TExtensionName>, ...args: TArgument[]): Promise<string>,\r\n    [arg: number]: TArgument,\r\n} & Iterable<TArgument> & {\r\n    escape(value: unknown): Promise<string>,\r\n    import(value: string): TemplateFunction;\r\n} & {\r\n    [name in TExtensionName]: TExtensions[TExtensionName];\r\n};\r\nexport type TemplateFunction = {\r\n    <TArgument>(...args: TArgument[]): Promise<string>;\r\n    toString(): string;\r\n};\r\nexport type TemplateOptions = {\r\n    verbose?: boolean;\r\n    async?: boolean;\r\n    cache?: boolean;\r\n    import?(value: string): string | Promise<string>;\r\n    escape?(value: string): string | Promise<string>;\r\n    extensions: Record<string, unknown>;\r\n};\r\nexport type TemplateCache = Map<string, string | TemplateFunction>;\r\nconst templateCache: TemplateCache = new Map<string, string | TemplateFunction>();\r\n\r\n// todo trim whitespace after <{ }>\r\nconst parseTemplate = (template: string, options: TemplateOptions) => {\r\n\r\n    const WHITESPACE = \" \".charCodeAt(0);\r\n    const TAB = \"\\t\".charCodeAt(0);\r\n    const RETURN = \"\\r\".charCodeAt(0);\r\n    const NEWLINE = \"\\n\".charCodeAt(0);\r\n    const UNDERSCORE = \"_\".charCodeAt(0);\r\n    const LOWERCASE_A = \"a\".charCodeAt(0);\r\n    const LOWERCASE_Z = \"z\".charCodeAt(0);\r\n    const UPPERCASE_A = \"A\".charCodeAt(0);\r\n    const UPPERCASE_Z = \"Z\".charCodeAt(0);\r\n    const NUMBER_0 = \"0\".charCodeAt(0);\r\n    const NUMBER_9 = \"9\".charCodeAt(0);\r\n    const OPEN_ANGLE = \"<\".charCodeAt(0);\r\n    const CLOSE_ANGLE = \">\".charCodeAt(0);\r\n    const OPEN_BRACE = \"{\".charCodeAt(0);\r\n    const CLOSE_BRACE = \"}\".charCodeAt(0);\r\n    const OPEN_PARENTHESES = \"(\".charCodeAt(0);\r\n    const CLOSE_PARENTHESES = \")\".charCodeAt(0);\r\n    const ASSIGN = \"=\".charCodeAt(0);\r\n    const TILDE = \"~\".charCodeAt(0);\r\n    const SLASH = \"/\".charCodeAt(0);\r\n    const ASTERISK = \"*\".charCodeAt(0);\r\n    const BACKSLASH = \"\\\\\".charCodeAt(0);\r\n    const APOSTROPHE = \"'\".charCodeAt(0);\r\n    const QUOTE = \"\\\"\".charCodeAt(0);\r\n    const BACKTICK = \"`\".charCodeAt(0);\r\n    const DOLLAR = \"$\".charCodeAt(0);\r\n    const AT_SIGN = \"@\".charCodeAt(0);\r\n    const isWhitespace = (c: number) => c === WHITESPACE || c === TAB || c === RETURN || c === NEWLINE;\r\n    const isAlphabetic = (c: number) => c === UNDERSCORE || (c >= LOWERCASE_A && c <= LOWERCASE_Z) || (c >= UPPERCASE_A && c <= UPPERCASE_Z);\r\n    const isAlphanumeric = (c: number) => isAlphabetic(c) || (c >= NUMBER_0 && c <= NUMBER_9);\r\n\r\n    let index = 0;\r\n    let startIndex = 0;\r\n    const length = template.length;\r\n    let funcBody = \"\";\r\n\r\n    const appendResult = (endIndex = index, extra = \"\") => {\r\n        if (endIndex > startIndex || extra) {\r\n            funcBody += `yield \\`${template.slice(startIndex, endIndex)}${extra}\\`;\\n`;\r\n        }\r\n    };\r\n\r\n    const appendOutput = (unsafe: boolean) => {\r\n        if (index > startIndex) {\r\n            funcBody += unsafe ?\r\n                `yield (${template.slice(startIndex, index)});\\n` :\r\n                `yield this.escape(${template.slice(startIndex, index)});\\n`;\r\n        }\r\n    };\r\n\r\n    const appendLogic = () => {\r\n        if (index > startIndex) {\r\n            funcBody += template.slice(startIndex, index);\r\n        }\r\n    };\r\n\r\n    const throwEndOfBlockExpected = (block: string) => {\r\n        throw new SyntaxError(`Expected end of ${block} at\\n${template}`);\r\n    };\r\n\r\n    const parseOpenBlock = (c: number) => {\r\n        const n = template.charCodeAt(index + 1);\r\n        if (c === OPEN_ANGLE && n === OPEN_BRACE) {\r\n            // Logic block <{\r\n            appendResult();\r\n            index += 2;\r\n            parseLogicBlock();\r\n            return true;\r\n        } else if (c === OPEN_BRACE && n === ASSIGN) {\r\n            // Assignment block {=\r\n            appendResult();\r\n            index += 2;\r\n            parseOutputBlock(false);\r\n            return true;\r\n        } else if (c === OPEN_BRACE && n === TILDE) {\r\n            // Unescape assignment block {~\r\n            appendResult();\r\n            index += 2;\r\n            parseOutputBlock(true);\r\n            return true;\r\n        } else if (c === OPEN_BRACE && n === AT_SIGN) {\r\n            // Declaration block {@\r\n            appendResult();\r\n            index += 2;\r\n            parseDeclaration();\r\n            return true;\r\n        } else if (c === BACKSLASH) {\r\n            // escape backslash \\\r\n            appendResult(index, \"\\\\\\\\\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        } else if (c === BACKTICK) {\r\n            // escape backtick\r\n            appendResult(index, \"\\\\`\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        } else if (c === DOLLAR) {\r\n            // escape dollar\r\n            appendResult(index, \"\\\\$\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    const parseLogicBlock = () => {\r\n        startIndex = index;\r\n        let isPotentialHtml = false;\r\n        while (index < length) {\r\n            if (parseStringOrComment()) {\r\n                continue;\r\n            }\r\n            const c = template.charCodeAt(index);\r\n            if (c === OPEN_BRACE) {\r\n                index++;\r\n                const n = template.charCodeAt(index);\r\n                if (n === CLOSE_ANGLE) {\r\n                    isPotentialHtml = false;\r\n                    appendLogic();\r\n                    index++;\r\n                    parseTextBlock();\r\n                } else if (n === ASSIGN || n === TILDE) {\r\n                    isPotentialHtml = false;\r\n                    appendLogic();\r\n                    index++;\r\n                    parseOutputBlock(n === TILDE);\r\n                    startIndex--;\r\n                } else if (n === AT_SIGN) {\r\n                    isPotentialHtml = false;\r\n                    index--;\r\n                    appendLogic();\r\n                    index += 2;\r\n                    parseDeclaration();\r\n                } else {\r\n                    isPotentialHtml = true;\r\n                }\r\n            } else if (isPotentialHtml && isWhitespace(c)) {\r\n                index++;\r\n            } else if (isPotentialHtml && c === OPEN_ANGLE) {\r\n                isPotentialHtml = false;\r\n                appendLogic();\r\n                parseHtmlBlock();\r\n            } else if (c === CLOSE_BRACE && template.charCodeAt(index + 1) === CLOSE_ANGLE) {\r\n                appendLogic();\r\n                index += 2;\r\n                startIndex = index;\r\n                return;\r\n            } else {\r\n                index++;\r\n                isPotentialHtml = false;\r\n            }\r\n        }\r\n        throwEndOfBlockExpected(\"logic block }>\");\r\n    };\r\n\r\n    const parseHtmlBlock = () => {\r\n        startIndex = index;\r\n        let potentialEnd = -1;\r\n        while (index < length) {\r\n            const c = template.charCodeAt(index);\r\n            if (c === CLOSE_ANGLE) {\r\n                index++;\r\n                potentialEnd = index;\r\n            } else if (potentialEnd >= 0 && isWhitespace(c)) {\r\n                index++;\r\n            } else if (potentialEnd >= 0 && parseStringOrComment(true)) {\r\n                // continue\r\n            } else if (potentialEnd >= 0 && c === CLOSE_BRACE) {\r\n                appendResult(potentialEnd);\r\n                startIndex = index;\r\n                return;\r\n            } else if (parseOpenBlock(c)) {\r\n                // continue\r\n            } else {\r\n                index++;\r\n                potentialEnd = -1;\r\n            }\r\n        }\r\n        throwEndOfBlockExpected(\"html block >}\");\r\n    };\r\n\r\n    const parseTextBlock = () => {\r\n        startIndex = index;\r\n        let potentialEnd = -1;\r\n        let potentialEndWhitespace = -1;\r\n        let hasMeaningfulSymbol = false;\r\n        while (index < length) {\r\n            const c = template.charCodeAt(index);\r\n            if (!hasMeaningfulSymbol && isWhitespace(c)) {\r\n                startIndex++;\r\n                index++;\r\n            } else if (parseOpenBlock(c)) {\r\n                hasMeaningfulSymbol = true;\r\n                potentialEnd = -1;\r\n                potentialEndWhitespace = -1;\r\n            } else if (c === OPEN_ANGLE || isWhitespace(c)) {\r\n                if (potentialEndWhitespace < 0) potentialEndWhitespace = index;\r\n                if (c === OPEN_ANGLE) potentialEnd = index;\r\n                index++;\r\n            } else if (potentialEnd >= 0 && isWhitespace(c)) {\r\n                index++;\r\n            } else if (potentialEnd >= 0 && c === CLOSE_BRACE) {\r\n                if (hasMeaningfulSymbol) {\r\n                    appendResult(potentialEndWhitespace);\r\n                }\r\n                startIndex = index;\r\n                return;\r\n            } else {\r\n                index++;\r\n                potentialEnd = -1;\r\n                potentialEndWhitespace = -1;\r\n                hasMeaningfulSymbol = true;\r\n            }\r\n        }\r\n        throwEndOfBlockExpected(\"text block <}\");\r\n    };\r\n\r\n    const parseOutputBlock = (unsafe: boolean) => {\r\n        startIndex = index;\r\n        const closeChar = unsafe ? TILDE : ASSIGN;\r\n        let hasMeaningfulSymbol = false;\r\n        let hasOnlyComment = false;\r\n        while (index < length) {\r\n            const sc = parseStringOrComment();\r\n            if (sc === 1) {\r\n                hasMeaningfulSymbol = true;\r\n                continue;\r\n            } else if (sc === 2 && !hasMeaningfulSymbol) {\r\n                hasOnlyComment = true;\r\n                startIndex = index;\r\n            }\r\n            const c = template.charCodeAt(index);\r\n            if (!hasMeaningfulSymbol && isWhitespace(c)) {\r\n                index++;\r\n            } else if (c === closeChar && template.charCodeAt(index + 1) === CLOSE_BRACE) {\r\n                if (hasMeaningfulSymbol) {\r\n                    appendOutput(unsafe);\r\n                } else if (!hasOnlyComment) {\r\n                    funcBody += `yield \\`${template.slice(startIndex, index)}\\`;`;\r\n                }\r\n                index += 2;\r\n                startIndex = index;\r\n                return;\r\n            } else {\r\n                index++;\r\n                hasMeaningfulSymbol = true;\r\n            }\r\n        }\r\n        throwEndOfBlockExpected(`output block ${unsafe ? \"~}\" : \"=}\"}`);\r\n    };\r\n\r\n    const parseStringOrComment = (onlyComment = false) => {\r\n        let isInString = 0;\r\n        let isInComment = 0;\r\n        let result = 0;\r\n        while (index < length) {\r\n            const c = template.charCodeAt(index);\r\n            let n = 0;\r\n            if (!onlyComment && !isInString && !isInComment && (c === APOSTROPHE || c === QUOTE || c === BACKTICK)) {\r\n                isInString = c;\r\n                index++;\r\n                result = 1;\r\n            } else if (isInString && c === BACKSLASH) {\r\n                index += 2;\r\n            } else if (isInString && c === isInString) {\r\n                index++;\r\n                return 1;\r\n            } else if (!isInString && !isInComment && c === SLASH && ((n = template.charCodeAt(index + 1)) === SLASH || n === ASTERISK)) {\r\n                isInComment = n;\r\n                index += 2;\r\n                result = 2;\r\n            } else if (isInComment === SLASH && c === NEWLINE) {\r\n                index++;\r\n                return 2;\r\n            } else if (isInComment === ASTERISK && c === ASTERISK && template.charCodeAt(index + 1) === SLASH) {\r\n                index += 2;\r\n                return 2;\r\n            } else if (isInComment || isInString) {\r\n                index++;\r\n            } else {\r\n                return 0;\r\n            }\r\n        }\r\n        if (result && isInString) {\r\n            throwEndOfBlockExpected(`string ${String.fromCharCode(isInString)}`);\r\n        }\r\n        if (result && isInComment === ASTERISK) {\r\n            throwEndOfBlockExpected(`comment */`);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    const parseDeclaration = () => {\r\n        startIndex = index;\r\n        let firstChar = 0;\r\n        let potentialName = false;\r\n        let name = \"\";\r\n        while (index < length) {\r\n            let c = template.charCodeAt(index);\r\n            if (!firstChar) {\r\n                c = skipWhitespace(c);\r\n                if (parseStringOrComment(true)) {\r\n                    c = skipWhitespace(template.charCodeAt(index));\r\n                }\r\n                startIndex = index;\r\n                firstChar = c;\r\n                if (c === OPEN_PARENTHESES) {\r\n                    index++;\r\n                    parseTemplateDeclaration();\r\n                    break;\r\n                } else if (c === APOSTROPHE || c === QUOTE || c === BACKTICK) {\r\n                    index++;\r\n                    parseImportDeclaration();\r\n                    break;\r\n                } else if (isAlphabetic(firstChar)) {\r\n                    index++;\r\n                    potentialName = true;\r\n                } else if (c === AT_SIGN && template.charCodeAt(index + 1) === CLOSE_BRACE) {\r\n                    index += 2;\r\n                    startIndex = index;\r\n                    return;\r\n                } else {\r\n                    parseParametersDeclaration();\r\n                    break;\r\n                }\r\n            } else if (potentialName && isAlphanumeric(c)) {\r\n                index++;\r\n            } else if (potentialName && !isAlphanumeric(c)) {\r\n                name = template.slice(startIndex, index);\r\n                c = skipWhitespace(c);\r\n                if (parseStringOrComment(true)) {\r\n                    c = skipWhitespace(template.charCodeAt(index));\r\n                }\r\n                if (c === OPEN_PARENTHESES) {\r\n                    index++;\r\n                    parseTemplateDeclaration(name);\r\n                    break;\r\n                } else if (c === APOSTROPHE || c === QUOTE || c === BACKTICK) {\r\n                    startIndex = index;\r\n                    index++;\r\n                    parseImportDeclaration(name);\r\n                    break;\r\n                } else {\r\n                    parseParametersDeclaration();\r\n                    break;\r\n                }\r\n            } else {\r\n                parseParametersDeclaration();\r\n                break;\r\n            }\r\n        }\r\n        skipWhitespace(template.charCodeAt(index));\r\n        startIndex = index;\r\n    };\r\n\r\n    const parseParametersDeclaration = () => {\r\n        while (index < length) {\r\n            if (parseStringOrComment(true)) {\r\n                // continue\r\n            } else if (template.charCodeAt(index) === AT_SIGN && template.charCodeAt(index + 1) === CLOSE_BRACE && index > startIndex) {\r\n                funcBody += `let[${template.slice(startIndex, index)}]=this;\\n`;\r\n                index += 2;\r\n                return;\r\n            } else {\r\n                index++;\r\n            }\r\n        }\r\n        throwEndOfBlockExpected(\"declaration block @}\");\r\n    };\r\n\r\n    const parseImportDeclaration = (name?: string) => {\r\n        while (index < length) {\r\n            if (parseStringOrComment(true)) {\r\n                // continue\r\n            } else if (template.charCodeAt(index) === AT_SIGN && template.charCodeAt(index + 1) === CLOSE_BRACE && index > startIndex) {\r\n                if (name) funcBody += `let ${name}=`;\r\n                funcBody += `this.import(${template.slice(startIndex, index)})\\n`;\r\n                index += 2;\r\n                return;\r\n            } else {\r\n                index++;\r\n            }\r\n        }\r\n        throwEndOfBlockExpected(\"declaration block @}\");\r\n    };\r\n\r\n    const parseTemplateDeclaration = (name?: string) => {\r\n        startIndex = index;\r\n        let parameters = \"\";\r\n        let parentheses = 0;\r\n        while (index < length) {\r\n            const c = template.charCodeAt(index);\r\n            if (c === OPEN_PARENTHESES) {\r\n                parentheses++;\r\n            } else if (c === CLOSE_PARENTHESES) {\r\n                if (parentheses) {\r\n                    parentheses--;\r\n                    index++;\r\n                } else {\r\n                    parameters = template.slice(startIndex, index);\r\n                    index++;\r\n                    skipWhitespace(template.charCodeAt(index));\r\n                    startIndex = index;\r\n                    break;\r\n                }\r\n            } else {\r\n                index++;\r\n            }\r\n        }\r\n        const tempFuncBody = funcBody;\r\n        let lastWhitespace = -1;\r\n        funcBody = \"\";\r\n        while (index < length) {\r\n            const c = template.charCodeAt(index);\r\n            if (isWhitespace(c)) {\r\n                lastWhitespace = index;\r\n                skipWhitespace(c);\r\n            } else if (c === AT_SIGN && template.charCodeAt(index + 1) === CLOSE_BRACE) {\r\n                appendResult(lastWhitespace > -1 ? lastWhitespace : index);\r\n                const innerFuncBody = funcBody;\r\n                funcBody = tempFuncBody;\r\n                if (name) {\r\n                    funcBody += `let ${name}=`;\r\n                }\r\n                funcBody += `(${options.async ? \"async \" : \"\"}function*(${parameters}){${innerFuncBody}}.bind(this))\\n`;\r\n                index += 2;\r\n                return;\r\n            } else if (parseOpenBlock(c)) {\r\n                // continue\r\n            } else {\r\n                index++;\r\n            }\r\n        }\r\n        throwEndOfBlockExpected(\"declaration block @}\");\r\n    };\r\n\r\n    const skipWhitespace = (c: number) => {\r\n        while (index < length && isWhitespace(c)) {\r\n            index++;\r\n            c = template.charCodeAt(index);\r\n        }\r\n        return c;\r\n    };\r\n\r\n    while (index < length) {\r\n        const c = template.charCodeAt(index);\r\n        if (parseOpenBlock(c)) {\r\n            // continue\r\n        } else {\r\n            index++;\r\n        }\r\n    }\r\n    appendResult();\r\n    return `return(${options.async ? \"async \" : \"\"}function*(){\\n${funcBody}}).call(this)`;\r\n};\r\n\r\nconst iterateRecursively = (value: any) => {\r\n    if (value && typeof value.next === \"function\") {\r\n        let result = \"\";\r\n        let loop = () => new Promise(r => r(value.next())).then((chunk: any): string | Promise<string> =>\r\n            chunk.done ? result : iterateRecursively(chunk.value).then(s => result = result + s).then(loop));\r\n        return loop().then(() => result);\r\n    }\r\n    return new Promise<string>(r => r(value));\r\n};\r\n\r\nconst isBrowser = Function(\"try{return this===window;}catch(e){return false;}\")();\r\n\r\nconst Nostache: {\r\n    (template: string | Promise<string>, options?: TemplateOptions): TemplateFunction;\r\n    readonly options: TemplateOptions,\r\n    readonly cache: TemplateCache,\r\n} = ((template: string | Promise<string>, options?: TemplateOptions): TemplateFunction => {\r\n    options = {\r\n        ...Nostache.options,\r\n        ...options\r\n    };\r\n    const extensions = {\r\n        ...(Nostache.options ? Nostache.options.extensions : undefined),\r\n        ...(options ? options.extensions : undefined)\r\n    };\r\n    const escapeFunc = (value: unknown) => {\r\n        return iterateRecursively(value).then(\r\n            typeof options.escape === \"function\" ? options.escape :\r\n                (s => s === undefined || s === null ? \"\" : String(s).replace(/[&<>\"']/g, c => `&#${c.charCodeAt(0)};`)));\r\n    };\r\n    const importFunc = (value: string) => (...args: unknown[]): Promise<string> => {\r\n        return Nostache(new Promise<string>((res, rej) => {\r\n            if (typeof options.import === \"function\") {\r\n                res(options.import(value));\r\n            } else {\r\n                const cachedTemplate = options.cache === false ? undefined : templateCache.get(value);\r\n                if (typeof cachedTemplate === \"string\") {\r\n                    res(cachedTemplate);\r\n                } else {\r\n                    (isBrowser ?\r\n                            fetch(value).then(r => r.text()) :\r\n                            new Promise<string>(r => require('fs').readFile(value, 'utf8', (e: any, d: string) => e ? rej(e) : r(d)))\r\n                    ).then(template => {\r\n                        if (options.cache !== false) {\r\n                            templateCache.set(value, template);\r\n                        }\r\n                        res(template);\r\n                    });\r\n                }\r\n            }\r\n        }), options)(...args);\r\n    };\r\n    const returnFunc = (...args: unknown[]): Promise<string> =>\r\n        new Promise<string>(r => r(template))\r\n            .then((templateString: string) => {\r\n                const cacheKey = options.async ? `async ${templateString}` : templateString;\r\n                let templateFunc = options.cache === false ? undefined : templateCache.get(cacheKey);\r\n                const templateFuncBody = templateFunc ? templateFunc.toString() : parseTemplate(templateString, options);\r\n                returnFunc.toString = () => `function () {\\n${templateFuncBody}\\n}`;\r\n                try {\r\n                    if (!templateFunc || typeof templateFunc === \"string\") {\r\n                        templateFunc = Function(templateFuncBody) as TemplateFunction;\r\n                        templateFunc.toString = () => templateFuncBody;\r\n                        if (options.cache !== false) {\r\n                            templateCache.set(cacheKey, templateFunc);\r\n                        }\r\n                    }\r\n                    if (options.verbose) {\r\n                        console.groupCollapsed(`(function () {`);\r\n                        console.log(`${templateFuncBody}})\\n(`, ...(args as any[]).reduce((a, t) => {\r\n                            if (a.length > 0) a.push(\",\");\r\n                            a.push(typeof t === \"string\" ? `\"${t}\"` : t);\r\n                            return a;\r\n                        }, []), \")\")\r\n                        console.groupEnd();\r\n                    }\r\n                    const contextFunc = ((...args: unknown[]) => returnFunc(...args)) as ContextFunction<unknown>;\r\n                    contextFunc[Symbol.iterator] = function* () {\r\n                        yield* args;\r\n                    };\r\n                    for (let i = 0; i < args.length; i++) {\r\n                        contextFunc[i] = args[i];\r\n                    }\r\n                    contextFunc.import = importFunc;\r\n                    contextFunc.escape = escapeFunc;\r\n                    for (const name in extensions) {\r\n                        contextFunc[name] = extensions[name];\r\n                    }\r\n                    return iterateRecursively(templateFunc.apply(contextFunc));\r\n                } catch (error: any) {\r\n                    error.message += `\\nat function () {\\n${templateFuncBody}\\n})(${\r\n                        args.map(t => typeof t === \"string\" ? `\"${t}\"` : t).join(\", \")\r\n                    })`;\r\n                    throw error;\r\n                }\r\n            });\r\n    return returnFunc;\r\n}) as typeof Nostache;\r\n\r\n(Nostache as { options: TemplateOptions }).options = {} as TemplateOptions;\r\n(Nostache as { cache: TemplateCache }).cache = templateCache;\r\n\r\nexport default Nostache;"],"names":["g","f","exports","module","define","amd","globalThis","self","Nostache","this","templateCache","Map","iterateRecursively","value","next","result","loop","Promise","r","then","chunk","done","s","isBrowser","Function","template","options","extensions","Object","assign","undefined","escapeFunc","escape","String","replace","c","charCodeAt","importFunc","args","res","rej","import","cachedTemplate","cache","get","fetch","text","require","readFile","e","d","set","returnFunc","templateString","cacheKey","async","templateFunc","templateFuncBody","toString","isWhitespace","isAlphabetic","isAlphanumeric","index","startIndex","length","funcBody","appendResult","endIndex","extra","slice","appendOutput","unsafe","appendLogic","throwEndOfBlockExpected","block","SyntaxError","parseOpenBlock","n","parseLogicBlock","parseOutputBlock","parseDeclaration","isPotentialHtml","parseStringOrComment","parseTextBlock","parseHtmlBlock","potentialEnd","potentialEndWhitespace","hasMeaningfulSymbol","closeChar","hasOnlyComment","sc","onlyComment","isInString","isInComment","fromCharCode","firstChar","potentialName","name","skipWhitespace","parseTemplateDeclaration","parseImportDeclaration","parseParametersDeclaration","parameters","parentheses","tempFuncBody","lastWhitespace","innerFuncBody","parseTemplate","verbose","console","groupCollapsed","log","reduce","a","t","push","groupEnd","contextFunc","Symbol","iterator","i","apply","error","message","map","join"],"mappings":"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"}