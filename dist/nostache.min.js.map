{"version":3,"file":"nostache.min.js","sources":["../src/index.ts"],"sourcesContent":["type TemplateFunction = ((...context: any[]) => Promise<string>) & {\r\n    verbose: boolean,\r\n    toString(): string,\r\n    escapeHtml(value: unknown): Promise<string>,\r\n};\r\nconst templateCache: Record<string, TemplateFunction> = {};\r\n\r\n// todo errors for unfinished expressions\r\n// todo extension functions\r\n// todo support of older browsers\r\n// todo expressions like <{ const f = {@ (a,b,c) <div>Inner Template {=i=}<div/> @} }> for inner templates in JS strings\r\n// todo expressions like {@ (a,b,c) @} for template arguments (no whitespace at the end)\r\n// todo expressions like <{ const f = {@ partials/partial.html @} }> for partials\r\n// todo output {=  =} or {~  ~} as whitespace `  `\r\n// todo layout/block/region technics\r\n// todo table of control characters in readme.md\r\n// todo ; before yield in some cases\r\nconst parseTemplate = (template: string) => {\r\n\r\n    const charCode = (char: string) => {\r\n        if (char.length > 1) {\r\n            const map: Record<number, boolean> = {};\r\n            for (let i = 0; i < char.length; i++) {\r\n                map[char.charCodeAt(i)] = true;\r\n            }\r\n            return map;\r\n        }\r\n        return char.charCodeAt(0);\r\n    };\r\n\r\n    const isWhitespace = charCode(\" \\t\\r\\n\") as Record<number, boolean>;\r\n    const isAlphabetic = (c: number) => c === 95 || (c >= 65 && c <= 90) || (c >= 97 && c <= 122);\r\n    const isAlphanumeric = (c: number) => isAlphabetic(c) || (c >= 48 && c <= 57);\r\n    const OPEN_ANGLE = charCode(\"<\");\r\n    const CLOSE_ANGLE = charCode(\">\");\r\n    const OPEN_BRACE = charCode(\"{\");\r\n    const CLOSE_BRACE = charCode(\"}\");\r\n    const OPEN_PARENTHESES = charCode(\"(\");\r\n    const CLOSE_PARENTHESES = charCode(\")\");\r\n    const ASSIGN = charCode(\"=\");\r\n    const TILDE = charCode(\"~\");\r\n    const SLASH = charCode(\"/\");\r\n    const ASTERISK = charCode(\"*\");\r\n    const NEWLINE = charCode(\"\\n\");\r\n    const BACKSLASH = charCode(\"\\\\\");\r\n    const APOSTROPHE = charCode(\"'\");\r\n    const QUOTE = charCode(\"\\\"\");\r\n    const BACKTICK = charCode(\"`\");\r\n    const DOLLAR = charCode(\"$\");\r\n    const AT_SIGN = charCode(\"@\");\r\n\r\n    let index = 0;\r\n    let startIndex = 0;\r\n    const length = template.length;\r\n    let funcBody = \"\";\r\n\r\n    const appendResult = (endIndex = index, extra = \"\") => {\r\n        if (endIndex > startIndex || extra) {\r\n            funcBody += `yield \\`${template.slice(startIndex, endIndex)}${extra}\\`;\\n`;\r\n        }\r\n    };\r\n\r\n    const appendOutput = (unsafe: boolean) => {\r\n        if (index > startIndex) {\r\n            funcBody += unsafe ?\r\n                `yield (${template.slice(startIndex, index)});\\n` :\r\n                `yield this.escapeHtml(${template.slice(startIndex, index)});\\n`;\r\n        }\r\n    };\r\n\r\n    const appendLogic = () => {\r\n        if (index > startIndex) {\r\n            funcBody += `${template.slice(startIndex, index)}`;\r\n        }\r\n    };\r\n\r\n    const parseOpenBlock = (c: number) => {\r\n        const n = template.charCodeAt(index + 1);\r\n        if (c === OPEN_ANGLE && n === OPEN_BRACE) {\r\n            // Logic block <{\r\n            appendResult();\r\n            index += 2;\r\n            parseLogicBlock();\r\n            return true;\r\n        } else if (c === OPEN_BRACE && n === ASSIGN) {\r\n            // Assignment block {=\r\n            appendResult();\r\n            index += 2;\r\n            parseOutputBlock(false);\r\n            return true;\r\n        } else if (c === OPEN_BRACE && n === TILDE) {\r\n            // Unsafe assignment block {~\r\n            appendResult();\r\n            index += 2;\r\n            parseOutputBlock(true);\r\n            return true;\r\n        } else if (c === OPEN_BRACE && n === AT_SIGN) {\r\n            // Declaration block {@\r\n            appendResult();\r\n            index += 2;\r\n            parseDeclaration();\r\n            return true;\r\n        } else if (c === BACKSLASH) {\r\n            // Escape backslash \\\r\n            appendResult(index, \"\\\\\\\\\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        } else if (c === BACKTICK) {\r\n            // Escape backtick\r\n            appendResult(index, \"\\\\`\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        } else if (c === DOLLAR) {\r\n            // Escape dollar\r\n            appendResult(index, \"\\\\$\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    const parseLogicBlock = () => {\r\n        startIndex = index;\r\n        let isPotentialHtml = true; // We can start html block right away\r\n        for (; index < length;) {\r\n            if (parseStringOrComment()) {\r\n                isPotentialHtml = false;\r\n                continue;\r\n            }\r\n            const c = template.charCodeAt(index);\r\n            if (c === OPEN_BRACE) {\r\n                index++;\r\n                const n = template.charCodeAt(index);\r\n                if (n === CLOSE_ANGLE) {\r\n                    isPotentialHtml = false;\r\n                    appendLogic();\r\n                    index++;\r\n                    parseTextBlock();\r\n                } else if (n === ASSIGN || n === TILDE) {\r\n                    isPotentialHtml = false;\r\n                    appendLogic();\r\n                    index++;\r\n                    parseOutputBlock(n === TILDE);\r\n                    startIndex--;\r\n                } else if (n === AT_SIGN) {\r\n                    isPotentialHtml = false;\r\n                    index--;\r\n                    appendLogic();\r\n                    index += 2;\r\n                    parseDeclaration();\r\n                } else {\r\n                    isPotentialHtml = true;\r\n                }\r\n            } else if (isPotentialHtml && isWhitespace[c]) {\r\n                index++;\r\n            } else if (isPotentialHtml && c === OPEN_ANGLE) {\r\n                isPotentialHtml = false;\r\n                appendLogic();\r\n                parseHtmlBlock();\r\n            } else if (c === CLOSE_BRACE && template.charCodeAt(index + 1) === CLOSE_ANGLE) {\r\n                appendLogic();\r\n                index += 2;\r\n                break;\r\n            } else {\r\n                index++;\r\n                isPotentialHtml = false;\r\n            }\r\n        }\r\n        startIndex = index;\r\n    };\r\n\r\n    const parseHtmlBlock = () => {\r\n        startIndex = index;\r\n        let potentialEnd = -1;\r\n        for (; index < length;) {\r\n            const c = template.charCodeAt(index);\r\n            if (c === CLOSE_ANGLE) {\r\n                index++;\r\n                potentialEnd = index;\r\n            } else if (potentialEnd >= 0 && isWhitespace[c]) {\r\n                index++;\r\n            } else if (potentialEnd >= 0 && c === CLOSE_BRACE) {\r\n                appendResult(potentialEnd);\r\n                break;\r\n            } else if (parseOpenBlock(c)) {\r\n                // continue\r\n            } else {\r\n                index++;\r\n                potentialEnd = -1;\r\n            }\r\n        }\r\n        startIndex = index;\r\n    };\r\n\r\n    const parseTextBlock = () => {\r\n        startIndex = index;\r\n        let potentialEnd = -1;\r\n        let potentialEndWhitespace = -1;\r\n        let hasMeaningfulSymbol = false;\r\n        for (; index < length;) {\r\n            const c = template.charCodeAt(index);\r\n            if (!hasMeaningfulSymbol && isWhitespace[c]) {\r\n                startIndex++;\r\n                index++;\r\n            } else if (hasMeaningfulSymbol && (c === OPEN_ANGLE || isWhitespace[c])) {\r\n                if (potentialEndWhitespace < 0) potentialEndWhitespace = index;\r\n                if (c === OPEN_ANGLE) potentialEnd = index;\r\n                index++;\r\n            } else if (potentialEnd >= 0 && isWhitespace[c]) {\r\n                index++;\r\n            } else if (potentialEnd >= 0 && c === CLOSE_BRACE) {\r\n                appendResult(potentialEndWhitespace);\r\n                break;\r\n            } else if (parseOpenBlock(c)) {\r\n                hasMeaningfulSymbol = true;\r\n            } else {\r\n                index++;\r\n                potentialEnd = -1;\r\n                potentialEndWhitespace = -1;\r\n                hasMeaningfulSymbol = true;\r\n            }\r\n        }\r\n        startIndex = index;\r\n    };\r\n\r\n    const parseOutputBlock = (unsafe: boolean) => {\r\n        startIndex = index;\r\n        const closeChar = unsafe ? TILDE : ASSIGN;\r\n        let hasMeaningfulSymbol = false;\r\n        for (; index < length;) {\r\n            if (parseStringOrComment()) {\r\n                hasMeaningfulSymbol = true;\r\n                continue;\r\n            }\r\n            const c = template.charCodeAt(index);\r\n            if (!hasMeaningfulSymbol && isWhitespace[c]) {\r\n                index++;\r\n            } else if (c === closeChar && template.charCodeAt(index + 1) === CLOSE_BRACE) {\r\n                if (hasMeaningfulSymbol) {\r\n                    appendOutput(unsafe);\r\n                }\r\n                index += 2;\r\n                break;\r\n            } else {\r\n                index++;\r\n                hasMeaningfulSymbol = true;\r\n            }\r\n        }\r\n        startIndex = index;\r\n    };\r\n\r\n    const parseStringOrComment = () => {\r\n        let isInString = 0;\r\n        let isInComment = 0;\r\n        let result = false;\r\n        for (; index < length;) {\r\n            const c = template.charCodeAt(index);\r\n            let n = 0;\r\n            if (!isInString && !isInComment && (c === APOSTROPHE || c === QUOTE || c === BACKTICK)) {\r\n                isInString = c;\r\n                index++;\r\n                result = true;\r\n            } else if (isInString && c === BACKSLASH) {\r\n                index += 2;\r\n            } else if (isInString && c === isInString) {\r\n                isInString = 0;\r\n                index++;\r\n                return true;\r\n            } else if (!isInString && !isInComment && c === SLASH && ((n = template.charCodeAt(index + 1)) === SLASH || n === ASTERISK)) {\r\n                isInComment = n;\r\n                index += 2;\r\n                result = true;\r\n            } else if (isInComment === SLASH && c === NEWLINE) {\r\n                isInComment = 0;\r\n                index++;\r\n            } else if (isInComment === ASTERISK && c === ASTERISK && template.charCodeAt(index + 1) === SLASH) {\r\n                isInComment = 0;\r\n                index += 2;\r\n                return true;\r\n            } else if (isInComment || isInString) {\r\n                index++;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    const parseDeclaration = () => {\r\n        startIndex = index;\r\n        let firstChar = 0;\r\n        let potentialName = false;\r\n        let name = '';\r\n        for (; index < length;) {\r\n            let c = template.charCodeAt(index);\r\n            if (!firstChar) {\r\n                c = skipWhitespace(c);\r\n                startIndex = index;\r\n                firstChar = c;\r\n                if (c === OPEN_PARENTHESES) {\r\n                    index++;\r\n                    parseFunctionDeclaration();\r\n                    break;\r\n                } else if (c === APOSTROPHE || c === QUOTE || c === BACKTICK) {\r\n                    parseTemplateDeclaration();\r\n                    break;\r\n                } else if (isAlphabetic(firstChar)) {\r\n                    index++;\r\n                    potentialName = true;\r\n                } else {\r\n                    parseParametersDeclaration();\r\n                    break;\r\n                }\r\n            } else if (potentialName && isAlphanumeric(c)) {\r\n                index++;\r\n            } else if (potentialName && !isAlphanumeric(c)) {\r\n                name = template.slice(startIndex, index);\r\n                c = skipWhitespace(c);\r\n                if (c === OPEN_PARENTHESES) {\r\n                    index++;\r\n                    startIndex = index;\r\n                    parseFunctionDeclaration(name);\r\n                    break;\r\n                } else if (c === APOSTROPHE || c === QUOTE || c === BACKTICK) {\r\n                    startIndex = index;\r\n                    parseTemplateDeclaration(name);\r\n                    break;\r\n                } else {\r\n                    parseParametersDeclaration();\r\n                    break;\r\n                }\r\n            } else {\r\n                parseParametersDeclaration();\r\n                break;\r\n            }\r\n        }\r\n        skipWhitespace(template.charCodeAt(index));\r\n        startIndex = index;\r\n    };\r\n\r\n    const parseParametersDeclaration = () => {\r\n        while (index < length) {\r\n            if (template.charCodeAt(index) === AT_SIGN && template.charCodeAt(index + 1) === CLOSE_BRACE && index > startIndex) {\r\n                funcBody += `let[${template.slice(startIndex, index)}]=this;\\n`;\r\n                index += 2;\r\n                break;\r\n            } else {\r\n                index++;\r\n            }\r\n        }\r\n    };\r\n\r\n    const parseTemplateDeclaration = (name?: string) => {\r\n        while (index < length) {\r\n            if (template.charCodeAt(index) === AT_SIGN && template.charCodeAt(index + 1) === CLOSE_BRACE && index > startIndex) {\r\n                if (name) funcBody += `${name}=`;\r\n                funcBody += `this.load(${template.slice(startIndex, index)});\\n`;\r\n                index += 2;\r\n            } else {\r\n                index++;\r\n            }\r\n        }\r\n    };\r\n\r\n    const parseFunctionDeclaration = (name?: string) => {\r\n\r\n    };\r\n\r\n    const skipWhitespace = (c: number) => {\r\n        while (index < length && isWhitespace[c]) {\r\n            index++;\r\n            c = template.charCodeAt(index);\r\n        }\r\n        return c;\r\n    };\r\n\r\n    for (; index < length;) {\r\n        const c = template.charCodeAt(index);\r\n        if (parseOpenBlock(c)) {\r\n            // continue\r\n        } else {\r\n            index++;\r\n        }\r\n    }\r\n    appendResult();\r\n    return `return(async function*(){\\n${funcBody}}).call(this)`;\r\n}\r\n\r\nconst escapeHtml = async (value: unknown) => {\r\n    return String(await value).replace(/[&<>\"']/g, c => `&#${c.charCodeAt(0)};`);\r\n};\r\n\r\nconst iterateGenerator = async (generator: AsyncGenerator<any>) => {\r\n    let result = '';\r\n    while (true) {\r\n        const chunk = await generator.next();\r\n        if (chunk.done) {\r\n            break;\r\n        } else {\r\n            if (typeof chunk.value?.next === \"function\") {\r\n                result += await iterateGenerator(chunk.value);\r\n            } else {\r\n                result += await chunk.value;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nconst Nostache = (template: string): TemplateFunction => {\r\n    if (templateCache[template]) {\r\n        return templateCache[template];\r\n    }\r\n    const funcBody = parseTemplate(template);\r\n    const templateFunc = async (...context: any[]) => {\r\n        try {\r\n            if (templateFunc.verbose) {\r\n                console.groupCollapsed(`(function () {`);\r\n                console.log(`${funcBody}})\\n(`, ...context.reduce((a, t) => {\r\n                    if (a.length > 0) a.push(\",\");\r\n                    a.push(typeof t === \"string\" ? `\"${t}\"` : t);\r\n                    return a;\r\n                }, []), \")\")\r\n                console.groupEnd();\r\n            }\r\n            const contextFunc = (...context: unknown[]) => {\r\n                return templateFunc(...context);\r\n            };\r\n            (contextFunc as any)[Symbol.iterator] = function* () {\r\n                yield* context;\r\n            };\r\n            for (let i = 0; i < context.length; i++) {\r\n                (contextFunc as any)[i] = context[i];\r\n            }\r\n            contextFunc.escapeHtml = templateFunc.escapeHtml;\r\n            const generator = Function(funcBody).apply(contextFunc);\r\n            return iterateGenerator(generator);\r\n        } catch (error: any) {\r\n            error.message += `\\nat function () {\\n${funcBody}\\n})(${\r\n                context.map(t => typeof t === \"string\" ? `\"${t}\"` : t).join(\", \")\r\n            })`;\r\n            throw error;\r\n        }\r\n    };\r\n    templateFunc.verbose = Nostache.verbose;\r\n    templateFunc.escapeHtml = escapeHtml;\r\n    templateFunc.toString = () => funcBody;\r\n    templateCache[template] = templateFunc;\r\n    return templateFunc;\r\n};\r\n\r\nNostache.verbose = false;\r\nNostache.escapeHtml = escapeHtml;\r\n\r\nexport default Nostache;"],"names":["templateCache","escapeHtml","async","value","String","replace","c","charCodeAt","iterateGenerator","generator","result","chunk","next","done","Nostache","template","funcBody","charCode","char","length","map","i","isWhitespace","isAlphabetic","isAlphanumeric","OPEN_ANGLE","CLOSE_ANGLE","OPEN_BRACE","CLOSE_BRACE","OPEN_PARENTHESES","ASSIGN","TILDE","SLASH","ASTERISK","NEWLINE","BACKSLASH","APOSTROPHE","QUOTE","BACKTICK","DOLLAR","AT_SIGN","index","startIndex","appendResult","endIndex","extra","slice","appendOutput","unsafe","appendLogic","parseOpenBlock","n","parseLogicBlock","parseOutputBlock","parseDeclaration","isPotentialHtml","parseStringOrComment","parseTextBlock","parseHtmlBlock","potentialEnd","potentialEndWhitespace","hasMeaningfulSymbol","closeChar","isInString","isInComment","firstChar","potentialName","name","skipWhitespace","parseTemplateDeclaration","parseParametersDeclaration","parseTemplate","templateFunc","context","verbose","console","groupCollapsed","log","reduce","a","t","push","groupEnd","contextFunc","Symbol","iterator","Function","apply","error","message","join","toString"],"mappings":"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"}