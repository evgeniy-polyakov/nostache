{"version":3,"file":"nostache.min.js","sources":["../src/index.ts"],"sourcesContent":["export type ContextFunction<TArgument, TExtensions extends Record<string, unknown> = Record<string, unknown>, TExtensionName extends keyof TExtensions = keyof TExtensions> = {\r\n    (this: ContextFunction<TArgument, TExtensions, TExtensionName>, ...args: TArgument[]): Promise<string>,\r\n    [arg: number]: TArgument,\r\n} & Iterable<TArgument> & {\r\n    escape(value: unknown): Promise<string>,\r\n    import(value: string | Promise<string>): TemplateFunction;\r\n} & {\r\n    [name in TExtensionName]: TExtensions[TExtensionName];\r\n};\r\nexport type TemplateFunction = {\r\n    <TArgument>(...args: TArgument[]): Promise<string>;\r\n    toString(): string;\r\n};\r\nexport type TemplateOptions = {\r\n    verbose?: boolean;\r\n    async?: boolean;\r\n    cache?: boolean | \"import\" | \"function\";\r\n    import?(value: string): string | Promise<string>;\r\n    escape?(value: string): string | Promise<string>;\r\n    extensions: Record<string, unknown>;\r\n};\r\nexport type TemplateCache = {\r\n    get(key: string, options?: \"function\" | \"async\"): TemplateFunction;\r\n    get(key: string, options: \"import\"): string;\r\n    set(key: string, value: TemplateFunction, options?: \"function\" | \"async\"): void;\r\n    set(key: string, value: string): void;\r\n    delete(key: string, options?: \"import\" | \"function\" | \"async\"): void;\r\n    clear(options?: \"import\" | \"function\" | \"async\"): void;\r\n};\r\nconst ASYNC = \"async\";\r\nconst IMPORT = \"import\";\r\nconst FUNCTION = \"function\";\r\nconst isString = (s: unknown): s is string => typeof s === \"string\";\r\nconst isFunction = (f: unknown): f is { (...args: any): any } => typeof f === FUNCTION;\r\nconst isNostache = Symbol(\"Nostache\");\r\n\r\nconst parseTemplate = (template: string, options: TemplateOptions) => {\r\n\r\n    const WHITESPACE = \" \".charCodeAt(0);\r\n    const TAB = \"\\t\".charCodeAt(0);\r\n    const RETURN = \"\\r\".charCodeAt(0);\r\n    const NEWLINE = \"\\n\".charCodeAt(0);\r\n    const UNDERSCORE = \"_\".charCodeAt(0);\r\n    const LOWERCASE_A = \"a\".charCodeAt(0);\r\n    const LOWERCASE_Z = \"z\".charCodeAt(0);\r\n    const UPPERCASE_A = \"A\".charCodeAt(0);\r\n    const UPPERCASE_Z = \"Z\".charCodeAt(0);\r\n    const NUMBER_0 = \"0\".charCodeAt(0);\r\n    const NUMBER_9 = \"9\".charCodeAt(0);\r\n    const OPEN_ANGLE = \"<\".charCodeAt(0);\r\n    const CLOSE_ANGLE = \">\".charCodeAt(0);\r\n    const OPEN_BRACE = \"{\".charCodeAt(0);\r\n    const CLOSE_BRACE = \"}\".charCodeAt(0);\r\n    const OPEN_PARENTHESES = \"(\".charCodeAt(0);\r\n    const CLOSE_PARENTHESES = \")\".charCodeAt(0);\r\n    const OPEN_BRACKET = \"[\".charCodeAt(0);\r\n    const CLOSE_BRACKET = \"]\".charCodeAt(0);\r\n    const ASSIGN = \"=\".charCodeAt(0);\r\n    const TILDE = \"~\".charCodeAt(0);\r\n    const SLASH = \"/\".charCodeAt(0);\r\n    const ASTERISK = \"*\".charCodeAt(0);\r\n    const BACKSLASH = \"\\\\\".charCodeAt(0);\r\n    const APOSTROPHE = \"'\".charCodeAt(0);\r\n    const QUOTE = \"\\\"\".charCodeAt(0);\r\n    const BACKTICK = \"`\".charCodeAt(0);\r\n    const DOLLAR = \"$\".charCodeAt(0);\r\n    const AT_SIGN = \"@\".charCodeAt(0);\r\n    const COMMA = \",\".charCodeAt(0);\r\n    const PERIOD = \".\".charCodeAt(0);\r\n    const isWhitespace = (c: number) => c === WHITESPACE || c === TAB || c === RETURN || c === NEWLINE;\r\n    const isAlphabetic = (c: number) => c === UNDERSCORE || (c >= LOWERCASE_A && c <= LOWERCASE_Z) || (c >= UPPERCASE_A && c <= UPPERCASE_Z);\r\n    const isAlphanumeric = (c: number) => isAlphabetic(c) || (c >= NUMBER_0 && c <= NUMBER_9);\r\n    const asyncModifier = options.async ? \"async \" : \"\";\r\n    const charAt = (i: number) => template.charCodeAt(i);\r\n\r\n    let index = 0;\r\n    let startIndex = 0;\r\n    const length = template.length;\r\n    let funcBody = \"\";\r\n\r\n    const appendResult = (endIndex = index, extra = \"\") => {\r\n        if (endIndex > startIndex || extra) {\r\n            funcBody += `yield \\`${template.slice(startIndex, endIndex)}${extra}\\`;\\n`;\r\n        }\r\n    };\r\n\r\n    const appendOutput = (unsafe: boolean) => {\r\n        if (index > startIndex) {\r\n            funcBody += unsafe ?\r\n                `yield (${template.slice(startIndex, index)});\\n` :\r\n                `yield this.escape(${template.slice(startIndex, index)});\\n`;\r\n        }\r\n    };\r\n\r\n    const appendLogic = () => {\r\n        if (index > startIndex) {\r\n            funcBody += `${template.slice(startIndex, index)}\\n`;\r\n        }\r\n    };\r\n\r\n    const throwEndOfBlockExpected = (block: string) => {\r\n        throw new SyntaxError(`Expected end of ${block} at\\n${template}`);\r\n    };\r\n\r\n    const throwEndOfDeclarationBlockExpected = () => throwEndOfBlockExpected(\"declaration block @}\");\r\n\r\n    const parseOpenBlock = (c: number) => {\r\n        const n = charAt(index + 1);\r\n        if (c === OPEN_ANGLE && n === OPEN_BRACE) {\r\n            // Logic block <{\r\n            appendResult();\r\n            index += 2;\r\n            parseLogicBlock();\r\n            return true;\r\n        } else if (c === OPEN_BRACE && n === ASSIGN) {\r\n            // Assignment block {=\r\n            appendResult();\r\n            index += 2;\r\n            parseOutputBlock(false);\r\n            return true;\r\n        } else if (c === OPEN_BRACE && n === TILDE) {\r\n            // Unescape assignment block {~\r\n            appendResult();\r\n            index += 2;\r\n            parseOutputBlock(true);\r\n            return true;\r\n        } else if (c === OPEN_BRACE && n === AT_SIGN) {\r\n            // Declaration block {@\r\n            appendResult();\r\n            index += 2;\r\n            parseDeclaration();\r\n            return true;\r\n        } else if (c === BACKSLASH) {\r\n            // escape backslash \\\r\n            appendResult(index, \"\\\\\\\\\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        } else if (c === BACKTICK) {\r\n            // escape backtick\r\n            appendResult(index, \"\\\\`\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        } else if (c === DOLLAR) {\r\n            // escape dollar\r\n            appendResult(index, \"\\\\$\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    const parseLogicBlock = () => {\r\n        startIndex = index;\r\n        let isPotentialHtml = false;\r\n        while (index < length) {\r\n            if (parseStringOrComment()) {\r\n                continue;\r\n            }\r\n            const c = charAt(index);\r\n            if (c === OPEN_BRACE) {\r\n                index++;\r\n                const n = charAt(index);\r\n                if (n === ASSIGN || n === TILDE) {\r\n                    isPotentialHtml = false;\r\n                    appendLogic();\r\n                    index++;\r\n                    parseOutputBlock(n === TILDE);\r\n                    startIndex--;\r\n                } else if (n === AT_SIGN) {\r\n                    isPotentialHtml = false;\r\n                    index--;\r\n                    appendLogic();\r\n                    index += 2;\r\n                    parseDeclaration();\r\n                } else {\r\n                    isPotentialHtml = true;\r\n                }\r\n            } else if (isPotentialHtml && isWhitespace(c)) {\r\n                index++;\r\n            } else if (isPotentialHtml && c === OPEN_ANGLE) {\r\n                isPotentialHtml = false;\r\n                appendLogic();\r\n                parseHtmlBlock();\r\n            } else if (isPotentialHtml && c === CLOSE_ANGLE) {\r\n                isPotentialHtml = false;\r\n                appendLogic();\r\n                index++;\r\n                parseTextBlock();\r\n            } else if (c === CLOSE_BRACE && charAt(index + 1) === CLOSE_ANGLE) {\r\n                appendLogic();\r\n                index += 2;\r\n                startIndex = index;\r\n                return;\r\n            } else {\r\n                index++;\r\n                isPotentialHtml = false;\r\n            }\r\n        }\r\n        throwEndOfBlockExpected(\"logic block }>\");\r\n    };\r\n\r\n    const parseHtmlBlock = () => {\r\n        startIndex = index;\r\n        let potentialEnd = -1;\r\n        while (index < length) {\r\n            const c = charAt(index);\r\n            if (parseOpenBlock(c)) {\r\n                potentialEnd = -1;\r\n            } else if (c === CLOSE_ANGLE) {\r\n                index++;\r\n                potentialEnd = index;\r\n            } else if (potentialEnd >= 0 && isWhitespace(c)) {\r\n                index++;\r\n            } else if (potentialEnd >= 0 && parseStringOrComment(true)) {\r\n                // continue\r\n            } else if (potentialEnd >= 0 && c === CLOSE_BRACE) {\r\n                appendResult(potentialEnd);\r\n                startIndex = index;\r\n                return;\r\n            } else {\r\n                index++;\r\n                potentialEnd = -1;\r\n            }\r\n        }\r\n        throwEndOfBlockExpected(\"html block >}\");\r\n    };\r\n\r\n    const parseTextBlock = () => {\r\n        startIndex = index;\r\n        let potentialEnd = -1;\r\n        while (index < length) {\r\n            const c = charAt(index);\r\n            if (parseOpenBlock(c)) {\r\n                potentialEnd = -1;\r\n            } else if (c === OPEN_ANGLE) {\r\n                potentialEnd = index;\r\n                index++;\r\n            } else if (potentialEnd >= 0 && isWhitespace(c)) {\r\n                index++;\r\n            } else if (potentialEnd >= 0 && c === CLOSE_BRACE) {\r\n                appendResult(potentialEnd);\r\n                startIndex = index;\r\n                return;\r\n            } else {\r\n                index++;\r\n                potentialEnd = -1;\r\n            }\r\n        }\r\n        throwEndOfBlockExpected(\"text block <}\");\r\n    };\r\n\r\n    const parseOutputBlock = (unsafe: boolean) => {\r\n        startIndex = index;\r\n        const closeChar = unsafe ? TILDE : ASSIGN;\r\n        let hasMeaningfulSymbol = false;\r\n        let hasOnlyComment = false;\r\n        while (index < length) {\r\n            const sc = parseStringOrComment();\r\n            if (sc === 1) {\r\n                hasMeaningfulSymbol = true;\r\n                continue;\r\n            } else if (sc === 2 && !hasMeaningfulSymbol) {\r\n                hasOnlyComment = true;\r\n                startIndex = index;\r\n            }\r\n            const c = charAt(index);\r\n            if (!hasMeaningfulSymbol && isWhitespace(c)) {\r\n                index++;\r\n            } else if (c === closeChar && charAt(index + 1) === CLOSE_BRACE) {\r\n                if (hasMeaningfulSymbol) {\r\n                    appendOutput(unsafe);\r\n                } else if (!hasOnlyComment) {\r\n                    funcBody += `yield \\`${template.slice(startIndex, index)}\\`;`;\r\n                }\r\n                index += 2;\r\n                startIndex = index;\r\n                return;\r\n            } else {\r\n                index++;\r\n                hasMeaningfulSymbol = true;\r\n            }\r\n        }\r\n        throwEndOfBlockExpected(`output block ${unsafe ? \"~}\" : \"=}\"}`);\r\n    };\r\n\r\n    const parseStringOrComment = (onlyComment = false) => {\r\n        let isInString = 0;\r\n        let isInComment = 0;\r\n        let result = 0;\r\n        while (index < length) {\r\n            const c = charAt(index);\r\n            let n = 0;\r\n            if (!onlyComment && !isInString && !isInComment && (c === APOSTROPHE || c === QUOTE || c === BACKTICK)) {\r\n                isInString = c;\r\n                index++;\r\n                result = 1;\r\n            } else if (isInString && c === BACKSLASH) {\r\n                index += 2;\r\n            } else if (isInString && c === isInString) {\r\n                index++;\r\n                return 1;\r\n            } else if (!isInString && !isInComment && c === SLASH && ((n = charAt(index + 1)) === SLASH || n === ASTERISK)) {\r\n                isInComment = n;\r\n                index += 2;\r\n                result = 2;\r\n            } else if (isInComment === SLASH && c === NEWLINE) {\r\n                index++;\r\n                return 2;\r\n            } else if (isInComment === ASTERISK && c === ASTERISK && charAt(index + 1) === SLASH) {\r\n                index += 2;\r\n                return 2;\r\n            } else if (isInComment || isInString) {\r\n                index++;\r\n            } else {\r\n                return 0;\r\n            }\r\n        }\r\n        if (result && isInString) {\r\n            throwEndOfBlockExpected(`string ${String.fromCharCode(isInString)}`);\r\n        }\r\n        if (result && isInComment === ASTERISK) {\r\n            throwEndOfBlockExpected(\"comment */\");\r\n        }\r\n        return result;\r\n    };\r\n\r\n    const parseDeclaration = () => {\r\n        startIndex = index;\r\n        let firstChar = 0;\r\n        let potentialName = false;\r\n        let name = \"\";\r\n        while (index < length) {\r\n            let c = charAt(index);\r\n            if (!firstChar) {\r\n                c = skipWhitespace();\r\n                if (parseStringOrComment(true)) {\r\n                    c = skipWhitespace();\r\n                }\r\n                startIndex = index;\r\n                firstChar = c;\r\n                if (c === OPEN_PARENTHESES) {\r\n                    index++;\r\n                    parseFunctionDeclaration();\r\n                    break;\r\n                } else if (isAlphabetic(firstChar)) {\r\n                    index++;\r\n                    potentialName = true;\r\n                } else if (c === AT_SIGN && charAt(index + 1) === CLOSE_BRACE) {\r\n                    index += 2;\r\n                    startIndex = index;\r\n                    return;\r\n                } else if (c === OPEN_BRACE || c === OPEN_BRACKET || c === PERIOD || c === COMMA) {\r\n                    parseParametersDeclaration();\r\n                    break;\r\n                } else {\r\n                    parseImportDeclaration();\r\n                    break;\r\n                }\r\n            } else if (potentialName && isAlphanumeric(c)) {\r\n                index++;\r\n            } else if (potentialName && !isAlphanumeric(c)) {\r\n                name = template.slice(startIndex, index);\r\n                c = skipWhitespace();\r\n                if (parseStringOrComment(true)) {\r\n                    c = skipWhitespace();\r\n                }\r\n                if (c === OPEN_PARENTHESES) {\r\n                    index++;\r\n                    parseFunctionDeclaration(name);\r\n                    break;\r\n                } else if (c === COMMA || (c === AT_SIGN && charAt(index + 1) === CLOSE_BRACE)) {\r\n                    parseParametersDeclaration();\r\n                    break;\r\n                } else {\r\n                    startIndex = index;\r\n                    parseImportDeclaration(name);\r\n                    break;\r\n                }\r\n            } else {\r\n                parseImportDeclaration();\r\n                break;\r\n            }\r\n        }\r\n        skipWhitespace();\r\n        startIndex = index;\r\n    };\r\n\r\n    const parseParametersDeclaration = () => {\r\n        while (index < length) {\r\n            if (parseStringOrComment(true)) {\r\n                // continue\r\n            } else if (charAt(index) === AT_SIGN && charAt(index + 1) === CLOSE_BRACE && index > startIndex) {\r\n                funcBody += `let[${template.slice(startIndex, index)}]=this;\\n`;\r\n                index += 2;\r\n                return;\r\n            } else {\r\n                index++;\r\n            }\r\n        }\r\n        throwEndOfDeclarationBlockExpected();\r\n    };\r\n\r\n    const parseImportDeclaration = (name?: string) => {\r\n        while (index < length) {\r\n            if (parseStringOrComment(true)) {\r\n                // continue\r\n            } else if (charAt(index) === AT_SIGN && charAt(index + 1) === CLOSE_BRACE && index > startIndex) {\r\n                if (name) funcBody += `let ${name}=`;\r\n                funcBody += `this.import(${template.slice(startIndex, index)})\\n`;\r\n                index += 2;\r\n                return;\r\n            } else {\r\n                index++;\r\n            }\r\n        }\r\n        throwEndOfDeclarationBlockExpected();\r\n    };\r\n\r\n    const parseFunctionDeclaration = (name?: string) => {\r\n        startIndex = index;\r\n        let parameters = \"\";\r\n        let parentheses = 0;\r\n        while (index < length) {\r\n            const c = charAt(index);\r\n            if (c === OPEN_PARENTHESES) {\r\n                parentheses++;\r\n            } else if (c === CLOSE_PARENTHESES) {\r\n                if (parentheses) {\r\n                    parentheses--;\r\n                    index++;\r\n                } else {\r\n                    parameters = template.slice(startIndex, index);\r\n                    index++;\r\n                    skipWhitespace();\r\n                    startIndex = index;\r\n                    break;\r\n                }\r\n            } else {\r\n                index++;\r\n            }\r\n        }\r\n        const tempFuncBody = funcBody;\r\n        let lastWhitespace = -1;\r\n        funcBody = \"\";\r\n        while (index < length) {\r\n            const c = charAt(index);\r\n            if (isWhitespace(c)) {\r\n                lastWhitespace = index;\r\n                skipWhitespace();\r\n            } else if (c === AT_SIGN && charAt(index + 1) === CLOSE_BRACE) {\r\n                appendResult(lastWhitespace > -1 ? lastWhitespace : index);\r\n                const innerFuncBody = funcBody;\r\n                funcBody = tempFuncBody;\r\n                if (name) {\r\n                    funcBody += `let ${name}=`;\r\n                }\r\n                funcBody += `(${asyncModifier}${FUNCTION}*(${parameters}){${innerFuncBody}}.bind(this))\\n`;\r\n                index += 2;\r\n                return;\r\n            } else if (parseOpenBlock(c)) {\r\n                // continue\r\n            } else {\r\n                index++;\r\n            }\r\n        }\r\n        throwEndOfDeclarationBlockExpected();\r\n    };\r\n\r\n    const skipWhitespace = () => {\r\n        let c = charAt(index);\r\n        while (index < length && isWhitespace(c)) {\r\n            index++;\r\n            c = charAt(index);\r\n        }\r\n        return c;\r\n    };\r\n\r\n    while (index < length) {\r\n        const c = charAt(index);\r\n        if (parseOpenBlock(c)) {\r\n            // continue\r\n        } else {\r\n            index++;\r\n        }\r\n    }\r\n    appendResult();\r\n    return `return(${asyncModifier}${FUNCTION}*(){\\n${funcBody}}).call(this)`;\r\n};\r\n\r\nconst iterateRecursively = (value: any) => {\r\n    if (value && isFunction(value.next)) {\r\n        let result = \"\";\r\n        const loop = () => new Promise(r => r(value.next())).then((chunk: any): string | Promise<string> => {\r\n            const v = chunk.value;\r\n            const d = chunk.done;\r\n            if (d && v === undefined) {\r\n                return result;\r\n            }\r\n            const p = iterateRecursively(v).then(s => result = result + s);\r\n            return d ? p : p.then(loop);\r\n        });\r\n        return loop().then(() => result);\r\n    }\r\n    if (value && value[isNostache]) {\r\n        return value(isNostache) as Promise<string>;\r\n    }\r\n    return new Promise<string>(r => r(value));\r\n};\r\n\r\nconst isBrowser = Function(\"try{return this===window;}catch(e){}\")();\r\n\r\nconst Nostache: {\r\n    (template: string | Promise<string>, options?: TemplateOptions): TemplateFunction;\r\n    readonly options: TemplateOptions,\r\n    readonly cache: TemplateCache,\r\n} = ((template: string | Promise<string>, options?: TemplateOptions): TemplateFunction => {\r\n    options = {\r\n        ...Nostache.options,\r\n        ...options\r\n    };\r\n    const extensions = {\r\n        ...(Nostache.options ? Nostache.options.extensions : undefined),\r\n        ...(options ? options.extensions : undefined)\r\n    };\r\n    const cache = options.cache;\r\n    const isAllCache = cache === undefined || cache === true;\r\n    const isImportCache = isAllCache || cache === IMPORT;\r\n    const isFunctionCache = isAllCache || cache === FUNCTION;\r\n    const escapeFunc = (value: unknown) => {\r\n        return iterateRecursively(value).then(\r\n            isFunction(options.escape) ? options.escape :\r\n                (s => s === undefined || s === null ? \"\" : String(s).replace(/[&<>\"']/g, c => `&#${c.charCodeAt(0)};`)));\r\n    };\r\n    const importFunc = (value: string | Promise<string>) => {\r\n        const deferImport = (...args: unknown[]): Promise<string> => Nostache(\r\n            new Promise<string>(r => r(value)).then(\r\n                value => new Promise<string>((res, rej) => {\r\n                    value = String(value);\r\n                    const cachedTemplate = isImportCache ? Nostache.cache.get(value, IMPORT) : undefined;\r\n                    if (cachedTemplate !== undefined) {\r\n                        res(cachedTemplate);\r\n                    } else {\r\n                        const cacheAndResolve = (template: string) => {\r\n                            if (isImportCache) {\r\n                                Nostache.cache.set(value, template);\r\n                            }\r\n                            res(template);\r\n                        };\r\n                        try {\r\n                            const optionsImport = options.import;\r\n                            if (isFunction(optionsImport)) {\r\n                                new Promise<string>(r => r(optionsImport(value))).then(cacheAndResolve);\r\n                            } else if (isBrowser) {\r\n                                fetch(value).then(response => response.status === 200 ? response.text().then(cacheAndResolve) : rej(new Error(`${response.status} ${response.url}`)));\r\n                            } else if (typeof require === FUNCTION) {\r\n                                require(\"fs\").readFile(value, \"utf8\", (error: any, data: string) => error ? rej(error) : cacheAndResolve(data));\r\n                            } else {\r\n                                import(\"fs\").then(fs => fs.readFile(value, \"utf8\", (error: any, data: string) => error ? rej(error) : cacheAndResolve(data)));\r\n                            }\r\n                        } catch (e) {\r\n                            rej(e);\r\n                        }\r\n                    }\r\n                })), options)(...args);\r\n        deferImport[isNostache] = true;\r\n        return deferImport;\r\n    };\r\n    const returnFunc = (...args: unknown[]): Promise<string> =>\r\n        new Promise<string>(r => r(template))\r\n            .then((templateString: string) => {\r\n                if (args[0] === isNostache) {\r\n                    return templateString;\r\n                }\r\n                const cacheOptions = options.async ? ASYNC : undefined;\r\n                let templateFunc = isFunctionCache ? Nostache.cache.get(templateString, cacheOptions) : undefined;\r\n                const templateFuncBody = templateFunc ? templateFunc.toString() : parseTemplate(templateString, options);\r\n                returnFunc.toString = () => `${FUNCTION} () {\\n${templateFuncBody}\\n}`;\r\n                try {\r\n                    if (!templateFunc) {\r\n                        templateFunc = Function(templateFuncBody) as TemplateFunction;\r\n                        templateFunc.toString = () => templateFuncBody;\r\n                        if (isFunctionCache) {\r\n                            Nostache.cache.set(templateString, templateFunc, cacheOptions);\r\n                        }\r\n                    }\r\n                    if (options.verbose) {\r\n                        console.groupCollapsed(`(${FUNCTION} () {`);\r\n                        console.log(`${templateFuncBody}})\\n(`, ...(args as any[]).reduce((a, t) => {\r\n                            if (a.length > 0) a.push(\",\");\r\n                            a.push(isString(t) ? `\"${t}\"` : t);\r\n                            return a;\r\n                        }, []), \")\")\r\n                        console.groupEnd();\r\n                    }\r\n                    const contextFunc = ((...args: unknown[]) => returnFunc(...args)) as ContextFunction<unknown>;\r\n                    contextFunc[Symbol.iterator] = function* () {\r\n                        yield* args;\r\n                    };\r\n                    for (let i = 0; i < args.length; i++) {\r\n                        contextFunc[i] = args[i];\r\n                    }\r\n                    contextFunc.import = importFunc;\r\n                    contextFunc.escape = escapeFunc;\r\n                    for (const name in extensions) {\r\n                        contextFunc[name] = extensions[name];\r\n                    }\r\n                    return iterateRecursively(templateFunc.apply(contextFunc));\r\n                } catch (error: any) {\r\n                    error.message += `\\nat ${FUNCTION} () {\\n${templateFuncBody}\\n})(${\r\n                        args.map(t => isString(t) ? `\"${t}\"` : t).join(\", \")\r\n                    })`;\r\n                    throw error;\r\n                }\r\n            });\r\n    returnFunc[isNostache] = true;\r\n    return returnFunc;\r\n}) as typeof Nostache;\r\n\r\n(Nostache as { options: TemplateOptions }).options = {} as TemplateOptions;\r\n(Nostache as { cache: TemplateCache }).cache = (() => {\r\n    const cache = {\r\n        [IMPORT]: {} as Record<string, string>,\r\n        [ASYNC]: {} as Record<string, TemplateFunction>,\r\n        [FUNCTION]: {} as Record<string, TemplateFunction>,\r\n    };\r\n    return {\r\n        get(key: string, options?: \"import\" | \"function\" | \"async\") {\r\n            return cache[options || FUNCTION][key];\r\n        },\r\n        set(key: string, value: TemplateFunction | string, options?: \"function\" | \"async\") {\r\n            cache[isString(value) ? IMPORT : (options || FUNCTION)][key] = value;\r\n        },\r\n        delete(key: string, options?: \"import\" | \"function\" | \"async\") {\r\n            delete cache[options || FUNCTION][key];\r\n        },\r\n        clear(options?: \"import\" | \"function\" | \"async\") {\r\n            if (options) {\r\n                cache[options] = {};\r\n            } else {\r\n                cache[IMPORT] = {};\r\n                cache[ASYNC] = {};\r\n                cache[FUNCTION] = {};\r\n            }\r\n        },\r\n    } as TemplateCache;\r\n})();\r\n\r\nexport default Nostache;"],"names":["ASYNC","IMPORT","FUNCTION","isString","s","isFunction","f","isNostache","Symbol","iterateRecursively","value","next","result","loop","Promise","r","then","chunk","v","d","done","undefined","p","isBrowser","Function","Nostache","template","options","extensions","Object","assign","cache","isAllCache","isImportCache","isFunctionCache","escapeFunc","escape","String","replace","c","charCodeAt","importFunc","deferImport","args","res","rej","cachedTemplate","get","cacheAndResolve","set","optionsImport","import","fetch","response","status","text","Error","url","require","readFile","error","data","fs","e","returnFunc","templateString","cacheOptions","async","templateFunc","templateFuncBody","toString","isWhitespace","isAlphabetic","isAlphanumeric","asyncModifier","charAt","i","index","startIndex","length","funcBody","appendResult","endIndex","extra","slice","appendOutput","unsafe","appendLogic","throwEndOfBlockExpected","block","SyntaxError","throwEndOfDeclarationBlockExpected","parseOpenBlock","n","parseLogicBlock","parseOutputBlock","parseDeclaration","isPotentialHtml","parseStringOrComment","parseHtmlBlock","parseTextBlock","potentialEnd","closeChar","hasMeaningfulSymbol","hasOnlyComment","sc","onlyComment","isInString","isInComment","fromCharCode","firstChar","potentialName","name","skipWhitespace","parseFunctionDeclaration","parseParametersDeclaration","parseImportDeclaration","parameters","parentheses","tempFuncBody","lastWhitespace","innerFuncBody","parseTemplate","verbose","console","groupCollapsed","log","reduce","a","t","push","groupEnd","contextFunc","iterator","apply","message","map","join","key","clear"],"mappings":"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"}