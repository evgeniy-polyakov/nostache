{"version":3,"file":"nostache.min.js","sources":["../src/index.ts"],"sourcesContent":["function charCode(char: string) {\r\n    if (char.length > 1) {\r\n        const map: Record<number, boolean> = {};\r\n        for (let i = 0; i < char.length; i++) {\r\n            map[char.charCodeAt(i)] = true;\r\n        }\r\n        return map;\r\n    }\r\n    return char.charCodeAt(0);\r\n}\r\n\r\nconst isWhitespace = charCode(\" \\t\\r\\n\") as Record<number, boolean>;\r\nconst OPEN_ANGLE = charCode(\"<\");\r\nconst CLOSE_ANGLE = charCode(\">\");\r\nconst OPEN_BRACE = charCode(\"{\");\r\nconst CLOSE_BRACE = charCode(\"}\");\r\nconst SEMICOLON = charCode(\";\");\r\nconst EQUAL = charCode(\"=\");\r\nconst BACKSLASH = charCode(\"\\\\\");\r\nconst QUOTE = charCode(\"'\");\r\n\r\nexport default function Nostache(template: string): (context?: unknown) => string {\r\n\r\n    let index = 0;\r\n    let startIndex = 0;\r\n    const length = template.length;\r\n    const result = \"__var__\";\r\n    let funcBody = `let ${result}='';\\n`;\r\n\r\n    function appendResult(endIndex = index, extra = \"\") {\r\n        if (endIndex > startIndex || extra) {\r\n            funcBody += `${result}+='${template.slice(startIndex, endIndex)}${extra}';\\n`;\r\n        }\r\n    }\r\n\r\n    function appendOutput() {\r\n        if (index > startIndex) {\r\n            funcBody += `${result}+=${template.slice(startIndex, index)};\\n`;\r\n        }\r\n    }\r\n\r\n    function appendLogic() {\r\n        if (index > startIndex) {\r\n            funcBody += `${template.slice(startIndex, index)}\\n`;\r\n        }\r\n    }\r\n\r\n    function escapeChar(c: number) {\r\n        if (c === BACKSLASH) {\r\n            appendResult(index, \"\\\\\\\\\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        } else if (c === QUOTE) {\r\n            appendResult(index, \"\\\\'\");\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function parseOpenBlock(c: number) {\r\n        if (c === OPEN_ANGLE && template.charCodeAt(index + 1) === OPEN_BRACE) {\r\n            appendResult();\r\n            index += 2;\r\n            parseLogicBlock();\r\n            return true;\r\n        } else if (c === EQUAL && template.charCodeAt(index + 1) === OPEN_BRACE) {\r\n            appendResult();\r\n            index += 2;\r\n            parseOutputBlock();\r\n            return true;\r\n        } else if (c === OPEN_ANGLE && template.charCodeAt(index + 1) === SEMICOLON && template.charCodeAt(index + 2) === CLOSE_ANGLE) {\r\n            appendResult();\r\n            index++;\r\n            startIndex = index;\r\n            index++;\r\n            appendLogic();\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        } else if (escapeChar(c)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function parseStart() {\r\n        for (; index < length;) {\r\n            const c = template.charCodeAt(index);\r\n            if (parseOpenBlock(c)) {\r\n                // continue\r\n            } else {\r\n                index++;\r\n            }\r\n        }\r\n        appendResult();\r\n    }\r\n\r\n    function parseLogicBlock() {\r\n        startIndex = index;\r\n        let isPotentialHtml = true; // We can start html block right away\r\n        for (; index < length;) {\r\n            const c = template.charCodeAt(index);\r\n            if (c === OPEN_BRACE) {\r\n                index++;\r\n                isPotentialHtml = true;\r\n            } else if (isPotentialHtml && isWhitespace[c]) {\r\n                index++;\r\n            } else if (isPotentialHtml && c === OPEN_ANGLE) {\r\n                isPotentialHtml = false;\r\n                appendLogic();\r\n                parseHtmlBlock();\r\n            } else if (c === CLOSE_BRACE && template.charCodeAt(index + 1) === CLOSE_ANGLE) {\r\n                appendLogic();\r\n                index += 2;\r\n                break;\r\n            } else {\r\n                index++;\r\n                isPotentialHtml = false;\r\n            }\r\n        }\r\n        startIndex = index;\r\n    }\r\n\r\n    function parseHtmlBlock() {\r\n        startIndex = index;\r\n        let potentialEnd = -1;\r\n        for (; index < length;) {\r\n            const c = template.charCodeAt(index);\r\n            if (parseOpenBlock(c)) {\r\n                // continue\r\n            } else if (c === CLOSE_ANGLE) {\r\n                index++;\r\n                potentialEnd = index;\r\n            } else if (potentialEnd >= 0 && isWhitespace[c]) {\r\n                index++;\r\n            } else if (potentialEnd && c === CLOSE_BRACE) {\r\n                appendResult(potentialEnd);\r\n                break;\r\n            } else if (escapeChar(c)) {\r\n                // continue\r\n            } else {\r\n                index++;\r\n                potentialEnd = -1;\r\n            }\r\n        }\r\n        startIndex = index;\r\n    }\r\n\r\n    function parseOutputBlock() {\r\n        startIndex = index;\r\n        let hasMeaningfulSymbol = false;\r\n        for (; index < length;) {\r\n            const c = template.charCodeAt(index);\r\n            if (c === CLOSE_BRACE && template.charCodeAt(index + 1) === CLOSE_ANGLE) {\r\n                if (hasMeaningfulSymbol) {\r\n                    appendOutput();\r\n                }\r\n                index += 2;\r\n                break;\r\n            } else if (isWhitespace[c]) {\r\n                index++;\r\n            } else {\r\n                index++;\r\n                hasMeaningfulSymbol = true;\r\n            }\r\n        }\r\n        startIndex = index;\r\n    }\r\n\r\n    parseStart();\r\n    funcBody += `return ${result};`;\r\n\r\n    return (context?: unknown) => {\r\n        const argNames = [];\r\n        const argValues = [];\r\n        const baseObject = {};\r\n        if (context && typeof context === \"object\") {\r\n            for (const p in context) {\r\n                if (!(p in baseObject) && /^[_a-z]\\w*$/i.test(p)) {\r\n                    argNames.push(p);\r\n                    argValues.push((context as any)[p]);\r\n                }\r\n            }\r\n        }\r\n        try {\r\n            return Function(...argNames, funcBody).apply(context, argValues);\r\n        } catch (error: any) {\r\n            error.message += `\\nat function (${argNames.join(\", \")}) {\\n${funcBody}\\n}`;\r\n            throw error;\r\n        }\r\n    };\r\n}"],"names":["charCode","char","length","map","i","charCodeAt","isWhitespace","OPEN_ANGLE","CLOSE_ANGLE","OPEN_BRACE","CLOSE_BRACE","SEMICOLON","EQUAL","BACKSLASH","QUOTE","template","index","startIndex","result","funcBody","appendResult","endIndex","extra","slice","appendOutput","appendLogic","escapeChar","c","parseOpenBlock","isPotentialHtml","parseHtmlBlock","parseLogicBlock","hasMeaningfulSymbol","parseOutputBlock","potentialEnd","parseStart","context","argNames","argValues","baseObject","p","test","push","Function","apply","error","message","join"],"mappings":"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"}