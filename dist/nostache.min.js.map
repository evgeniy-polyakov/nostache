{"version":3,"file":"nostache.min.js","sources":["../src/index.ts"],"sourcesContent":["export function Nostache(template: string): (context?: unknown) => string {\r\n\r\n    let index = 0;\r\n    let startIndex = 0;\r\n    const length = template.length;\r\n    const result = \"__var__\";\r\n    let funcBody = `let ${result}='';\\n`;\r\n\r\n    const isWhitespace = {\r\n        [\" \".charCodeAt(0)]: true,\r\n        [\"\\t\".charCodeAt(0)]: true,\r\n        [\"\\r\".charCodeAt(0)]: true,\r\n        [\"\\n\".charCodeAt(0)]: true,\r\n    };\r\n    const OPEN_ANGLE = \"<\".charCodeAt(0);\r\n    const CLOSE_ANGLE = \">\".charCodeAt(0);\r\n    const OPEN_BRACE = \"{\".charCodeAt(0);\r\n    const CLOSE_BRACE = \"}\".charCodeAt(0);\r\n    const SEMICOLON = \";\".charCodeAt(0);\r\n    const EQUAL = \"=\".charCodeAt(0);\r\n\r\n    function appendResult() {\r\n        if (index > startIndex) {\r\n            funcBody += `${result}+='${sliceHtml()\r\n                .replace(/\\\\/g, \"\\\\\\\\\")\r\n                .replace(/'/g, \"\\\\'\")\r\n            }';\\n`;\r\n        }\r\n    }\r\n\r\n    function appendOutput() {\r\n        if (index > startIndex) {\r\n            funcBody += `${result}+=${sliceCode()};\\n`;\r\n        }\r\n    }\r\n\r\n    function appendLogic() {\r\n        if (index > startIndex) {\r\n            funcBody += `${sliceCode()}\\n`;\r\n        }\r\n    }\r\n\r\n    function sliceCode() {\r\n        return template\r\n            .slice(startIndex, index)\r\n            .replace(/^\\s+/, \"\")\r\n            .replace(/\\s+$/, \"\");\r\n    }\r\n\r\n    function sliceHtml() {\r\n        return template\r\n            .slice(startIndex, index)\r\n            .replace(/^\\s+</, \"<\")\r\n            .replace(/>\\s+$/, \">\");\r\n    }\r\n\r\n    function parseOpenBlock(c: number) {\r\n        if (c === OPEN_ANGLE && template.charCodeAt(index + 1) === OPEN_BRACE) {\r\n            appendResult();\r\n            index += 2;\r\n            parseLogicBlock();\r\n            return true;\r\n        } else if (c === EQUAL && template.charCodeAt(index + 1) === OPEN_BRACE) {\r\n            appendResult();\r\n            index += 2;\r\n            parseOutputBlock();\r\n            return true;\r\n        } else if (c === OPEN_ANGLE && template.charCodeAt(index + 1) === SEMICOLON && template.charCodeAt(index + 2) === CLOSE_ANGLE) {\r\n            appendResult();\r\n            index++;\r\n            startIndex = index;\r\n            index++;\r\n            appendLogic();\r\n            index++;\r\n            startIndex = index;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function parseStart() {\r\n        for (; index < length;) {\r\n            const c = template.charCodeAt(index);\r\n            if (parseOpenBlock(c)) {\r\n                // no action\r\n            } else {\r\n                index++;\r\n            }\r\n        }\r\n        appendResult();\r\n    }\r\n\r\n    function parseLogicBlock() {\r\n        startIndex = index;\r\n        let isPotentialHtml = true; // We can start html block right away\r\n        for (; index < length;) {\r\n            const c = template.charCodeAt(index);\r\n            if (c === OPEN_BRACE) {\r\n                index++;\r\n                isPotentialHtml = true;\r\n            } else if (isPotentialHtml && isWhitespace[c]) {\r\n                index++;\r\n            } else if (isPotentialHtml && c === OPEN_ANGLE) {\r\n                isPotentialHtml = false;\r\n                appendLogic();\r\n                parseHtmlBlock();\r\n            } else if (c === CLOSE_BRACE && template.charCodeAt(index + 1) === CLOSE_ANGLE) {\r\n                appendLogic();\r\n                index += 2;\r\n                break;\r\n            } else {\r\n                index++;\r\n                isPotentialHtml = false;\r\n            }\r\n        }\r\n        startIndex = index;\r\n    }\r\n\r\n    function parseHtmlBlock() {\r\n        startIndex = index;\r\n        let isPotentialEnd = false;\r\n        for (; index < length;) {\r\n            const c = template.charCodeAt(index);\r\n            if (parseOpenBlock(c)) {\r\n                // no action\r\n            } else if (c === CLOSE_ANGLE) {\r\n                index++;\r\n                isPotentialEnd = true;\r\n            } else if (isPotentialEnd && isWhitespace[c]) {\r\n                index++;\r\n            } else if (isPotentialEnd && c === CLOSE_BRACE) {\r\n                appendResult();\r\n                break;\r\n            } else {\r\n                index++;\r\n                isPotentialEnd = false;\r\n            }\r\n        }\r\n        startIndex = index;\r\n    }\r\n\r\n    function parseOutputBlock() {\r\n        startIndex = index;\r\n        let hasMeaningfulSymbol = false;\r\n        for (; index < length;) {\r\n            const c = template.charCodeAt(index);\r\n            if (c === CLOSE_BRACE && template.charCodeAt(index + 1) === CLOSE_ANGLE) {\r\n                if (hasMeaningfulSymbol) {\r\n                    appendOutput();\r\n                }\r\n                index += 2;\r\n                break;\r\n            } else if (isWhitespace[c]) {\r\n                index++;\r\n            } else {\r\n                index++;\r\n                hasMeaningfulSymbol = true;\r\n            }\r\n        }\r\n        startIndex = index;\r\n    }\r\n\r\n    parseStart();\r\n    funcBody += `return ${result};`;\r\n\r\n    return (context?: unknown) => {\r\n        const argNames = [];\r\n        const argValues = [];\r\n        const baseObject = {};\r\n        if (context && typeof context === \"object\") {\r\n            for (const p in context) {\r\n                if (!(p in baseObject) && /^[_a-z]\\w*$/i.test(p)) {\r\n                    argNames.push(p);\r\n                    argValues.push((context as any)[p]);\r\n                }\r\n            }\r\n        }\r\n        try {\r\n            return Function(...argNames, funcBody).apply(context, argValues);\r\n        } catch (error: any) {\r\n            error.message += `\\nat function (${argNames.join(\", \")}) {\\n${funcBody}\\n}`;\r\n            throw error;\r\n        }\r\n    };\r\n}"],"names":["exports","Nostache","template","index","startIndex","length","result","funcBody","isWhitespace","charCodeAt","OPEN_ANGLE","CLOSE_ANGLE","OPEN_BRACE","CLOSE_BRACE","SEMICOLON","EQUAL","appendResult","slice","replace","appendOutput","sliceCode","appendLogic","parseOpenBlock","c","isPotentialHtml","parseHtmlBlock","parseLogicBlock","hasMeaningfulSymbol","parseOutputBlock","isPotentialEnd","parseStart","context","argNames","argValues","baseObject","p","test","push","Function","apply","error","message","join"],"mappings":"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"}